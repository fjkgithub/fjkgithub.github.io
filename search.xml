<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[easyExcel导入导出]]></title>
    <url>%2F2019%2F09%2F18%2FeasyExcel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[依赖的jar包pom.xml导入依赖包 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@Slf4jpublic class ExportExcel &#123; /** * fileName: 表明 * keys：字段 * Map&lt;String, Object&gt;map：字段对应的值 * titleList：表头 * List&lt;Map&lt;String, Object&gt;&gt; mapList：所有对象的字段对应的值 */ public static void contextLoads(HttpServletResponse response, String fileName,List&lt;String&gt; keys, List&lt;String&gt; titleList,List&lt;Map&lt;String, Object&gt;&gt; mapList) &#123; // 文件输出位置 OutputStream out = null; try &#123; // 取得输出流 out = response.getOutputStream(); // 中文文件名问题 String attachment = new String(("attachment;filename=" + fileName + ".xlsx").getBytes("UTF-8"), "ISO8859-1"); // 清空输出流 response.reset(); // 设定输出文件头 response.setHeader("Content-disposition", attachment); // 定义输出类型 response.setContentType("application/msexcel"); ExcelWriter writer = new ExcelWriter(out, ExcelTypeEnum.XLSX); // 写仅有一个 Sheet 的 Excel 文件, 此场景较为通用 Sheet sheet1 = new Sheet(1, 0); // 设置标题 Table table = new Table(1); List&lt;List&lt;String&gt;&gt; titles = new ArrayList&lt;List&lt;String&gt;&gt;(); for (String title : titleList)&#123; titles.add(Arrays.asList(title)); &#125; table.setHead(titles); List&lt;List&lt;Object&gt;&gt; dateList = new ArrayList&lt;&gt;(); mapList.stream().forEach(x-&gt;&#123; List&lt;Object&gt; row = new ArrayList&lt;&gt;(); for (Object str : keys)&#123; Object obj = x.get(str); row.add(obj); &#125; dateList.add(row); &#125;); writer.write1(dateList,sheet1,table); // 第一个 sheet 名称 sheet1.setSheetName("第一个sheet"); // 将上下文中的最终 outputStream 写入到指定文件中 writer.finish(); &#125; catch (Exception e) &#123; log.error("导出[" + fileName + "]报表异常!" + e.getMessage(), e); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; log.error("关闭流异常!" + e.getMessage(), e); &#125; &#125; &#125; &#125; /** * 导入excel * @param inputStream * @param excelListener * @param clazz 需继承BaseRowModel基础类 * @param suffixName 文件后缀 * @throws Exception */ private static void readExcel(InputStream inputStream, ExcelListener excelListener,Class clazz,String suffixName) throws Exception&#123; try &#123; ExcelTypeEnum excelTypeEnum; if (ExcelTypeEnum.XLSX.getValue().equalsIgnoreCase(suffixName)) &#123; excelTypeEnum = ExcelTypeEnum.XLSX; &#125; else if (ExcelTypeEnum.XLS.getValue().equalsIgnoreCase(suffixName)) &#123; excelTypeEnum = ExcelTypeEnum.XLS; &#125;else&#123; throw new Exception("文件上传格式错误"); &#125; ExcelReader excelReader = new ExcelReader(inputStream,excelTypeEnum,null, excelListener); excelReader.read(new Sheet(1,1,clazz)); &#125;catch (Exception e)&#123; log.error("导入文件异常",e); throw new Exception("导入文件失败"); &#125;finally &#123; if(inputStream != null)&#123; inputStream.close(); &#125; &#125; &#125; /** * 读取excel * @param inputStream * @param clazz 需继承BaseRowModel基础类 * @param suffixName * @return * @throws Exception */ public static List&lt;Object&gt; readExcel(InputStream inputStream,Class clazz,String suffixName) throws Exception&#123; ExcelListener listener = new ExcelListener(); readExcel(inputStream,listener,clazz,suffixName); return listener.getDataList(); &#125;&#125; 导出excel的使用类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@Controller@RequestMapping("/commandParse")public class CommandParseController extends BaseAction &#123; @Autowired private CommandParseService commandParseService; /** * 分页查询 */ @RequestMapping("/page") public ModelAndView pageChannel(CommandParse commandParse) &#123; boolean excel = request.getParameter("excel")!= null &amp;&amp; Boolean.parseBoolean(params.get("excel") + ""); try &#123; resultBean = commandParseService.pageAll(excel,commandParse,getBaseConditionVo()); //渠道列表 List&lt;Channel&gt; channels = channelService.getChannelList(); mv.addObject("commandParse",commandParse); mv.addObject("channels",channels); if (excel)&#123; ExportBean exportBean = new ExportBean(); exportBean.setPageNow(0); //导出10万条 exportBean.setPageSize(100000); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); List&lt;CommandParse&gt; list = resultBean.getResults(); map.put("list", list); map.put("param", exportBean); return new ModelAndView(new CommandCodeExport(), map); &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage()); return ajaxDoneError(MessageCode.SERVER_ERROR[1]); &#125; return pageResult(resultBean, "user/ad/pageCommandParse"); &#125;&#125;public class CommandCodeExport extends AbstractExcelView &#123; @Override protected void buildExcelDocument(Map&lt;String, Object&gt; paramMap, HSSFWorkbook workbook, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; @SuppressWarnings("unchecked") List&lt;CommandParse&gt; list = (List&lt;CommandParse&gt;) paramMap.get("list"); ExportBean param = (ExportBean) paramMap.get("param"); //导出显示列 String showClo = (String) paramMap.get("showClo"); DecimalFormat df = new DecimalFormat("#.00"); List&lt;Map&lt;String, Object&gt;&gt; mapList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; //bean转map Map&lt;String,Object&gt; map = ExportExcelUtil.&lt;String, Object&gt; BeanJsonMap(list.get(i)); map.put("id",i+1); map.put("updateTime", DateUtil.formatDate(list.get(i).getUpdateTime(),"yyyy-MM-dd")); if(list.get(i).getStatus()==1)&#123; map.put("status","开启"); &#125;else &#123; map.put("status","关闭"); &#125; mapList.add(map); &#125; String fileName = "书籍口令列表"+DateUtil.formatDate(new Date(),DateUtil.YYYYMMDDHHMMSS); List&lt;String&gt; keysList = new ArrayList&lt;String&gt;(); List&lt;String&gt; titlesList = new ArrayList&lt;String&gt;(); exportPageColKeysTitle(showClo,keysList, titlesList); //调用导出excel方法 ExportExcel.contextLoads(response,fileName,keysList,titlesList,mapList); &#125; private boolean exportPageColKeysTitle(String showClo,List&lt;String&gt; keysList, List&lt;String&gt; titlesList)&#123; Map&lt;String,String&gt; temp = Constants.commandCodeMap; for (Map.Entry&lt;String, String&gt; stringStringEntry : temp.entrySet()) &#123; keysList.add(stringStringEntry.getKey()); titlesList.add(stringStringEntry.getValue()); &#125; return true; &#125; private &lt;K, V&gt; Map&lt;K, V&gt; BeanJsonMap(Object javaBean) &#123; if(javaBean == null ) return null; String json = gson.toJson(javaBean); return JsonUtil.fromJson(json,Map.class); &#125;&#125; 导入excel的使用类12345678910111213141516 /** * 上传Excel文件 */ @RequestMapping("/uploadFileProgress")public ModelAndView uploadFileProgress(@RequestParam(value = "uploadXls", required = false) MultipartFile pkgFile, Long bookListId)&#123; try &#123; String fileName = pkgFile.getOriginalFilename(); String suffixName = fileName.substring(fileName.lastIndexOf(".")); List&lt;Object&gt; dataList = ExportExcel.readExcel(pkgFile.getInputStream(),AppBookListBook.class,suffixName); appBookListBookService.batchSave(dataList,bookListId); &#125;catch (Exception e)&#123; logger.error(e.getMessage()); return ajaxDoneError(MessageCode.SERVER_ERROR[1]); &#125; return ajaxDoneSuccess("保存成功");&#125;]]></content>
      <categories>
        <category>excel</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加解密、压缩工具]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8A%A0%E8%A7%A3%E5%AF%86%E3%80%81%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class SecurityUtil &#123; private static Log log = LogFactory.getLog(SecurityUtil.class); private static SecretKeySpec getSecretKey(String key) throws Exception &#123; SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); DESKeySpec keySpec = new DESKeySpec(key.getBytes()); keyFactory.generateSecret(keySpec); return new SecretKeySpec(keyFactory.generateSecret(keySpec).getEncoded(), "DES"); &#125; /** * 功能描述: DES加密 */ public static String encryptDES(String key, byte[] b) &#123; if (!StringUtils.isEmpty(key) &amp;&amp; b != null &amp;&amp; b.length &gt; 0) &#123; try &#123; SecretKeySpec secretKey = getSecretKey(key); Cipher cipher = Cipher.getInstance("DES"); cipher.init(Cipher.ENCRYPT_MODE, secretKey); return Base64.encodeToString(cipher.doFinal(b), Base64.NO_WRAP); &#125; catch (Throwable throwable) &#123; log.error("DES加密出错", throwable); &#125; &#125; return ""; &#125; /** * 功能描述: DES解密 */ public static byte[] decryptDES(String key, String data) &#123; if (!StringUtils.isEmpty(key) &amp;&amp; !StringUtils.isEmpty(data)) &#123; try &#123; SecretKeySpec secretKey = getSecretKey(key); Cipher cipher = Cipher.getInstance("DES"); cipher.init(Cipher.DECRYPT_MODE, secretKey); return cipher.doFinal(Base64.decode(data, Base64.NO_WRAP)); &#125; catch (Throwable throwable) &#123; log.error("DES解密出错", throwable); &#125; &#125; return null; &#125; /** * 功能描述: RSA加密 */ public static String encryptRSA(String publicKeyString, String data) &#123; if (!StringUtils.isEmpty(publicKeyString) &amp;&amp; !StringUtils.isEmpty(data)) &#123; try &#123; PublicKey key = decodePublicKey(publicKeyString); //Cipher.getInstance("RSA"); Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); cipher.init(Cipher.ENCRYPT_MODE, key); return Base64.encodeToString(cipher.doFinal(data.getBytes()), Base64.NO_WRAP); &#125; catch (Throwable throwable) &#123; log.error("RSA加密出错", throwable); &#125; &#125; return ""; &#125; /** * 功能描述: RSA解密 */ public static String decryptRSA(String privateKeyString, String data) &#123; if (!StringUtils.isEmpty(privateKeyString) &amp;&amp; !StringUtils.isEmpty(data)) &#123; try &#123; PrivateKey key = decodePrivateKey(privateKeyString); //Cipher.getInstance("RSA"); Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); cipher.init(Cipher.DECRYPT_MODE, key); byte[] bytes = cipher.doFinal(Base64.decode(data, Base64.NO_WRAP)); return new String(bytes); &#125; catch (Throwable throwable) &#123; log.error("RSA解密出错", throwable); &#125; &#125; return ""; &#125; private static String encodeKeyToString(Key key)&#123; return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125; private static PrivateKey decodePrivateKey(String key) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); return keyFactory.generatePrivate(keySpec); &#125; private static PublicKey decodePublicKey(String key) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); return keyFactory.generatePublic(keySpec); &#125; /** * 功能描述: 生成RSA的公钥和私钥 */ private static void generateKeyPair() &#123; try &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA"); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); System.out.println("public:\n" + encodeKeyToString(keyPair.getPublic())); System.out.println("private:\n" + encodeKeyToString(keyPair.getPrivate())); &#125; catch (Throwable throwable) &#123; log.error("RSA生成密钥出错", throwable); &#125; &#125; /** * 功能描述: zip压缩 */ public static byte[] compress(String str) &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); if (!StringUtils.isEmpty(str)) &#123; GZIPOutputStream gzip = null; try &#123; gzip = new GZIPOutputStream(out); gzip.write(str.getBytes("utf-8")); gzip.close(); &#125; catch (IOException var6) &#123; var6.printStackTrace(); &#125; &#125; return out.toByteArray(); &#125; /** * 功能描述: zip解压缩 */ public static String uncompress(byte[] bytes) &#123; if (bytes == null || bytes.length == 0) &#123; return null; &#125; ByteArrayOutputStream out = new ByteArrayOutputStream(); ByteArrayInputStream in = new ByteArrayInputStream(bytes); try &#123; GZIPInputStream ungzip = new GZIPInputStream(in); byte[] buffer = new byte[256]; int n; while ((n = ungzip.read(buffer)) &gt;= 0) &#123; out.write(buffer, 0, n); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; return out.toString("utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; String publickey = "dfsfsfdsfsdgfdgdsfgfgfdgfdshgfhthjthbsbfbdfssdfgsdfrhdsB"; String desKey = "ENKLIFANGMINDT123"; TestParam param = new TestParam(); param.setImei("123456789"); param.setImsi("987654321"); String data = JsonUtil.toJson(param); String paramdesrsakey = encryptRSA(publickey, desKey); String paramencryptData = encryptDES(desKey, SecurityUtil.compress(data)); System.out.println("paramdesrsakey:" + paramdesrsakey); System.out.println("paramencryptData:" + paramencryptData); String res = SecurityUtil.uncompress(decryptDES(desKey, paramencryptData)); System.out.println("res:" + res); &#125;&#125;]]></content>
      <categories>
        <category>加解密和压缩</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口上下行json转换]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%8E%A5%E5%8F%A3%E4%B8%8A%E4%B8%8B%E8%A1%8Cjson%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[容器注入MappingJackson2HttpMessageConverter123456789@Configurationpublic class HttpMessageConverterConfig &#123; @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter () &#123; return new PushMappingJackson2HttpMessageConverter(); &#125;&#125; 声名类继承MappingJackson2HttpMessageConverter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class PushMappingJackson2HttpMessageConverter extends org.springframework.http.converter.json.MappingJackson2HttpMessageConverter &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; if(sra!=null)&#123; HttpServletRequest request = sra.getRequest(); String key = request.getHeader(Constants.SecurityConstans.HEADER_ENCRYPTKEY_REQUEST); key = SecurityUtil.decryptRSA(Constants.SecurityConstans.privateKey, key); request.setAttribute(Constants.SecurityConstans.HEADER_ENCRYPTKEY_KEY, key); InputStream body = inputMessage.getBody(); byte[] bytes = new byte[body.available()]; body.read(bytes); String data = ""; if (bytes.length != 0) &#123; data = SecurityUtil.uncompress(SecurityUtil.decryptDES(key, new String(bytes))); &#125; Object obj = null; if (StringUtils.isEmpty(data)) &#123; logger.info("客户端上传数据为空,不予处理"); return obj; &#125; try &#123; obj = this.objectMapper.readValue(data, this.getJavaType(type, contextClass)); &#125; catch (Exception e) &#123; logger.warn("数据解析异常\nJSON：" + data, e.getMessage() + e); &#125; return obj; &#125;else&#123; return super.read(type,contextClass,inputMessage); &#125; &#125; @Override protected void writeInternal(Object object, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; if(sra!=null)&#123; HttpServletRequest request = sra.getRequest(); String uri = request.getRequestURI(); if(uri!= null &amp;&amp; !uri.startsWith("/admin/"))&#123; String encryptKey = (String) request.getAttribute(Constants.SecurityConstans.HEADER_ENCRYPTKEY_KEY); if(!StringUtils.isBlank(encryptKey)) &#123; outputMessage.getBody().write(SecurityUtil.encryptDES(encryptKey, SecurityUtil.compress(JsonUtil.toJson(object))).getBytes()); &#125; &#125;else&#123; outputMessage.getBody().write(JsonUtil.toJson(object).getBytes()); &#125; &#125;else&#123; outputMessage.getBody().write(JsonUtil.toJson(object).getBytes()); &#125; &#125;&#125; 常量类1234567891011121314151617181920212223public class Constants &#123; public static final class ReturnResult &#123; public static final String RETURN_RESULT_OK = "ok"; public static final String RETURN_RESULT_FAIL = "fail"; public ReturnResult() &#123; &#125; &#125; public static class SecurityConstans &#123; public static final String HEADER_ENCRYPTKEY_REQUEST = "enKey"; public static final String HEADER_ENCRYPTKEY_KEY = "HEADER_ENTRY_KEY"; //获取项目中resources目录下encrypt.properties private static ResourceBundle securityBundle = ResourceBundle.getBundle("encrypt"); public static String privateKey = securityBundle.getString("privateKey"); public static String publicKey = securityBundle.getString("publicKey"); &#125; public static final String CACHE_PREFIX="cache";&#125; controller1234567891011121314151617181920212223242526272829303132333435363738public class BaseController &#123; public &lt;T&gt; BaseValueVO&lt;T&gt; returnSuccess(T t) &#123; BaseValueVO&lt;T&gt; baseValueVO = new BaseValueVO&lt;T&gt;(); baseValueVO.setData(t); baseValueVO.setStatus(Constants.ReturnResult.RETURN_RESULT_OK); return baseValueVO; &#125;&#125;@Controllerpublic class TestController extends BaseController&#123; /** * 功能描述: 有返回值，状态码200 */ @RequestMapping(value = &#123;"/test"&#125;) @ResponseBody @MetricManage public BaseValueVO&lt;TestValue&gt; updateImei(@RequestBody TestParam testParam) throws Exception &#123; TestValue tv=new TestValue(); tv.setName("test"); tv.setAge(123); return super.returnSuccess(tv); &#125; /** * 无返回值，状态码204 */ @RequestMapping(value = &#123;"/noContentTest"&#125;) @ResponseStatus(HttpStatus.NO_CONTENT) public void test(@RequestBody TestParam testParam)&#123; TestValue tv=new TestValue(); tv.setName("test"); tv.setAge(123); &#125;&#125; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public abstract class TestAbstract &#123; String url; Map baseDataParam; public TestAbstract(String url, Map baseDataParam)&#123; this.url = url; this.baseDataParam = baseDataParam; &#125; public void test() &#123; Map dataParam = new HashMap&lt;&gt;(); dataParam.putAll(baseDataParam); this.initDataParam(dataParam); CloseableHttpResponse httppHttpResponse2 = null; CloseableHttpClient httpClient = HttpClients.createDefault(); try &#123; HttpPost httpPost = new HttpPost(url); httpPost.setHeader("Content-Type", "application/json"); String desKey= UUID.randomUUID().toString(); httpPost.setHeader(Constants.SecurityConstans.HEADER_ENCRYPTKEY_REQUEST,SecurityUtil.encryptRSA(Constants.SecurityConstans.publicKey,desKey)); String json = JsonUtil.toJson(dataParam); httpPost.setEntity(new StringEntity(SecurityUtil.encryptDES(desKey,SecurityUtil.compress(json)), ContentType.APPLICATION_JSON)); httppHttpResponse2 = httpClient.execute(httpPost); System.out.println(httppHttpResponse2.getStatusLine()); if(httppHttpResponse2.getStatusLine().getStatusCode()== HttpStatus.SC_OK) &#123; System.out.println(SecurityUtil.uncompress(SecurityUtil.decryptDES(desKey,EntityUtils.toString(httppHttpResponse2.getEntity())))); &#125;else&#123; System.out.println(httppHttpResponse2.getStatusLine().getStatusCode()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; httppHttpResponse2.close(); httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; protected abstract void initDataParam(Map dataParam); public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public Map getBaseDataParam() &#123; return baseDataParam; &#125; public void setBaseDataParam(Map baseDataParam) &#123; this.baseDataParam = baseDataParam; &#125;&#125;public class TestLogStats &#123; //基础测试数据信息 Map baseDataParam = new HashMap&lt;&gt;(); //基础测试数据信息 List baseDataParamList = new ArrayList(); /** * 有返回值的测试类 */ @Test public void onlineOperateTest() throws UnsupportedEncodingException &#123; String url = "http://localhost:8080/test"; baseDataParamList.add("123"); baseDataParamList.add("456"); new TestAbstract(url, baseDataParam) &#123; @Override protected void initDataParam(Map dataParam) &#123; dataParam.put("imei","123455"); dataParam.put("imsi","999999"); dataParam.put("param",baseDataParamList); &#125; &#125;.test(); &#125; /** * 无返回值的测试类 */ @Test public void noContentTest() throws UnsupportedEncodingException &#123; String url = Config.host.concat("/noContentTest"); new TestAbstract(url, baseDataParam) &#123; @Override protected void initDataParam(Map dataParam) &#123; dataParam.put("imei","123455"); dataParam.put("imsi","999999"); &#125; &#125;.test(); &#125;&#125;]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>压缩</tag>
        <tag>josn转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义注解以及AOP]]></title>
    <url>%2F2019%2F09%2F17%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8AAOP%2F</url>
    <content type="text"><![CDATA[自定义注解123456789101112@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataChangeTrigger &#123; String tableName(); /** * 操作类型 * @return */ String operatorType() default ""; int keyIndex() default 0;&#125; 拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Aspect@Componentpublic class DateChangeAop &#123; protected Logger logger = LoggerFactory.getLogger(this.getClass()); @Around("within(com.zzcm..*) &amp;&amp; @annotation(dataChangeTrigger)") public Object around(ProceedingJoinPoint pjp, DataChangeTrigger dataChangeTrigger) throws Throwable &#123; try &#123; Object o = pjp.proceed(); this.trigger(pjp.getSignature().getName(),pjp.getArgs(),o,dataChangeTrigger); return o; &#125; catch (Throwable e) &#123; throw e; &#125; &#125; private void trigger(String methodName,Object [] inputParam,Object returnValue,DataChangeTrigger dataChangeTrigger) throws Exception &#123; Collection&lt;Object&gt; key; String operatorType=this.parseOperatorType(methodName,dataChangeTrigger); if(operatorType.equals(Constatns.OPERATOR_TYPE_ADD))&#123; key=this.parseKey(returnValue); &#125;else&#123; key=this.parseKey(inputParam[dataChangeTrigger.keyIndex()]); &#125; try &#123; logger.info("刷新缓存!-----"+dataChangeTrigger.tableName() + "-----" + key+"-----"+operatorType); if(CollectionUtils.isEmpty(key)) return; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (Object k:key)&#123; list.add(k.toString()); &#125; CacheBean cacheBean = new CacheBean(dataChangeTrigger.tableName(),list,operatorType); &#125;catch(Exception e)&#123; logger.error(e.getMessage(),e); &#125; &#125; private Collection parseKey(Object o) throws IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Collection key=new ArrayList(); if(o instanceof PKInterface)&#123; key.add(((PKInterface) o).getPK()); &#125;else if(o instanceof Collection)&#123; key.addAll((Collection)o); &#125;else&#123; key.add(o); &#125; return key; &#125; private String parseOperatorType(String methodName,DataChangeTrigger dataChangeTrigger) throws Exception &#123; String operatorType=""; if(StringUtils.isNotEmpty(dataChangeTrigger.operatorType()))&#123; operatorType=dataChangeTrigger.operatorType(); &#125;else&#123; if(methodName.startsWith("save"))&#123; operatorType= Constatns.OPERATOR_TYPE_ADD; &#125;else if(methodName.startsWith("update"))&#123; operatorType= Constatns.OPERATOR_TYPE_UPDATE; &#125;else if(methodName.startsWith("del"))&#123; operatorType= Constatns.OPERATOR_TYPE_DELETE; &#125; &#125; if (!operatorType.equals(Constatns.OPERATOR_TYPE_ADD) &amp;&amp; !operatorType.equals(Constatns.OPERATOR_TYPE_UPDATE) &amp;&amp; operatorType.equals(Constatns.OPERATOR_TYPE_DELETE)) &#123; throw new Exception("operator_type error! operator_type is:" + operatorType); &#125; return operatorType; &#125; private boolean isSimpleObject(Object o)&#123; return o instanceof Integer||o.getClass().isArray(); &#125;&#125; 使用1234@DataChangeTrigger(tableName = "video_television",operatorType = "update") public void updateVideoTelevision(VideoTelevision videoTelevision) &#123; //业务代码 &#125;]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>自定义注解</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地缓存]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[BaseHolder1234567891011121314151617181920212223242526272829303132333435public abstract class BaseHolder&lt;T&gt; &#123; private SortedMap&lt;String, T&gt; map_m = new TreeMap&lt;&gt;(); private SortedMap&lt;String, T&gt; map_s = new TreeMap&lt;&gt;(); private boolean ISMASTER = true; public SortedMap&lt;String,T&gt; getData()&#123; if(ISMASTER)&#123; return map_m; &#125;else&#123; return map_s; &#125; &#125; public void setData(SortedMap&lt;String,T&gt; data)&#123; if(ISMASTER)&#123; map_s = data; &#125;else&#123; map_m = data; &#125; ISMASTER = !ISMASTER; &#125; public T get(String key)&#123; SortedMap&lt;String, T&gt; data = getData(); if(null==data) return null; return getData().get(key); &#125; public SortedMap&lt;String, T&gt; get()&#123; SortedMap&lt;String, T&gt; data = getData(); if(null==data) return null; return data; &#125;&#125; BaseJob 任务的基类1234567891011121314151617181920212223242526272829303132333435363738394041424344@Order(value = 1)public abstract class BaseJob implements CommandLineRunner &#123; protected Logger logger = LoggerFactory.getLogger(this.getClass()); public abstract void execute(); @Override public void run(String... strings) &#123; this.execute(); &#125; /** * 设置holder 缓存 * @param t 缓存数据 * @param baseHolder holder * @param acceptEmpty 是否允许空数据刷缓存 * @param &lt;T&gt; */ protected &lt;T extends SortedMap&gt; void setHolderData(T t, BaseHolder baseHolder, boolean acceptEmpty) &#123; if (t == null) &#123; return; &#125; if (!t.isEmpty()) &#123; baseHolder.setData(t); return; &#125; if (acceptEmpty) &#123; baseHolder.setData(t); &#125; &#125; /** * 设置holder 缓存，不允许空数据刷holder * @param t 缓存数据 * @param baseHolder holder * @param &lt;T&gt; */ protected &lt;T extends SortedMap&gt; void setHolderData(T t, BaseHolder baseHolder)&#123; setHolderData(t,baseHolder,false); &#125;&#125; 定时任务12345678910111213141516171819202122232425262728293031@Componentpublic class AdOriginConfigJob extends BaseJob &#123; @Autowired private AdOriginConfigHolder adOriginConfigHolder; @Scheduled(cron = "$&#123;ad.origin.config.job&#125;") @PostConstruct @Override public void execute() &#123; Constants.JobEnum jobEnum = Constants.JobEnum.AD_ORIGIN_CONFIG_JOB; Long begin=System.currentTimeMillis(); logger.info("JOB &#123;&#125; 开始执行...", jobEnum.getDesc()); String response = ebkSynServiceFeign.getAdOriginConfigList(); try &#123; //1 获取数据 SortedMap&lt;String, List&lt;AdOriginConfigBean&gt;&gt; adOriginConfigHolderSortedMap = 查数据库; //2 设置缓存数据 this.setHolderData(adOriginConfigHolderSortedMap, adOriginConfigHolder,true); &#125; catch (MiroServiceException e) &#123; logger.error("JOB &#123;&#125; 执行失败,CODE &#123;&#125; Message &#123;&#125;", new String[]&#123;jobEnum.getDesc(), e.getCode(), e.getMessage()&#125;, e); &#125; catch (Exception e) &#123; logger.error("JOB &#123;&#125; 执行失败!", jobEnum.getDesc()); logger.error(e.getMessage(), e); &#125; Long end=System.currentTimeMillis(); logger.info("JOB &#123;&#125; 执行结束...,花费&#123;&#125;毫秒", jobEnum.getDesc(),end-begin); &#125;&#125; CacheManager1234567891011@Service("cacheManager")@Slf4jpublic class CacheManager &#123; @Autowired private AdOriginConfigHolder adOriginConfigHolder; public List&lt;AdOriginConfigBean&gt; getAdOriginConfigList() &#123; List&lt;AdOriginConfigBean&gt; adOriginConfigBeanList = adOriginConfigHolder.get(Constants.JOB_LIST_DEFAULT_KEY); return adOriginConfigBeanList; &#125;&#125; 定时任务线程池,为了达到并行12345678@Configurationpublic class SchedukeConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) &#123; scheduledTaskRegistrar.setScheduler(Executors.newScheduledThreadPool(10)); &#125;&#125; 启动类1234567@SpringBootApplication@EnableSchedulingpublic class EbkPushApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EbkPushApplication.class, args); &#125;&#125;]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>本地缓存</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F09%2F16%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[tail-f fileName命令用于查看文件内容最后10行数据，ctrl+c退出。 最基本的是cat、more和less。看的是文件全部内容，内容很多的话，不方便。 tail -f [ -n Number ] [ File ] 查看最新的，会刷新，可以用ctrl+c 来终止 例如：tail -f -n 10 fileName 查看最后10行最新消息。（默认是10行）chmod授权方式。chown -R更改文件夹的用户 tmp 目录为所有用户可读可写权限：chmod -R 777 /tmp 修改 tmp 目录所属用户为 root，用户组为 root ： chown -R root:root /tmp详细查看某个java项目有没有起、以及项目的进程PID(1)ps -ef |grep 项目名 (2)jps -l --&gt;查看所有java的进程查看linux的各个磁盘的使用率和所占空间df -h查看当前目录及子目录的大小du -h查看当前目录的一级目录的大小du -ah --max-depth=1查看所有文件的详情ll -h cd ~查看某个目录cd .. 查看上一层目录 cd -回到上次的目录查找文件find /home/ad -name iad* 查看/home/ad目录下前缀为iad的所有文件 find /home/ad -inname iad* 查看/home/ad目录下前缀为iad的所有文件（忽略大小写） find /home/ad -size +20M 查看/home/ad目录下大于20M的所有文件压缩和解压(1)zip 文件 ①zip 文件名.zip 源文件 ---》压缩文件 ②zip 目录名.zip 源目录 ----》压缩目录 ③unzip 压缩文件名.zip ---》解压文件 ④unzip -r 压缩目录名.zip ---》解压目录 (2)tar 文件 ①tar -cvf 压缩文件名.tar 源文件 ---》压缩文件 ②tar -xvf 压缩文件名.tar ---》解压文件 (3)tag.gz 文件 ①tar -zcvf 压缩文件名.tar.gz 源文件 ---》压缩文件 ②tar -zxvf 压缩文件名.tar.gz ---》解压文件 (4)gz ①gzip 文件名.gz 源文件 ---》压缩文件 ②gzip -r 目录名.gz 源目录 ----》压缩目录 ③guzip 文件名.gz ----》解压文件 ④guzip -r 目录名.gz ---》解压目录 查看输入命令的历史记录history输出重定向(1)shell命令 &gt;&gt; 文件名.log 2&gt;&amp;1 同时追加正确命令和错误命令到 指定文件 (2)shell命令 &gt;&gt;文件.log 1 2&gt;&gt;文件.log 2 把正确的命令输出到文件1错误的文件2查看路由表route -n将本机文件复制到远程服务器上scp 文件的绝对路径 root@远程ip:远程具体目录 Lg: scp /home/ad/log.txt root@192.168.1.110:/home/log常用快捷键ctrl+c 终止当前命令 ctrl+l 清屏 相当于clear]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea快捷键]]></title>
    <url>%2F2019%2F09%2F16%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用快捷键 快捷键 提示 alt+insert 生成代码(如get,set方法,构造函数等) alt+enter 导入包 alt+F7 查看某个方法在哪里有用到,或者按ctrl+鼠标点击 ctrl+e 最近更改的代码 ctrl+r 替换文本 ctrl+f 查找文本 ctrl+空格 代码提示 ctrl+p 方法参数提示 ctrl+shit+space 自动提示 ctrl+shit+enter 自动补全 ctrl+x 删除行 ctrl+d 复制行 ctrl＋F12 可以显示当前文件的结构 ctrl+alt+ left/right 返回至上次浏览的位置 ctrl＋alt＋t 可以把代码包在一块内，例如try/catch if ctrl+alt+l 格式化代码 ctrl+alt+o 去掉没有用的import包 ctrl+alt+t 快速生成if else try catch ctrl+h 查询类的父类和子类的层级关系 ctrl+alt+b 查看子类方法实现 ctrl+/ 或 ctrl+chift+/ 注释（// 或者/…/ ） shift+shift 搜索任何東西 shift+F6 重构 – 重命名 ctrl+n 查找哪个类 ctrl+shift+n 查找哪个文件 ctrl+z 撤回 ctrl+shift+z 恢复撤回 图片]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown使用手册]]></title>
    <url>%2F2019%2F08%2F27%2FMarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 换行1&lt;/br&gt; 分割线1*** 文字样式1234567891011*斜体***加粗**==高亮==~~划线~~&lt;font color=#2196F3 size=2 face=&quot;宋体&quot;&gt;宋体大小为2蓝色的字&lt;/font&gt;&lt;center&gt;居中&lt;/center&gt; 斜体加粗==高亮==划线宋体大小为2蓝色的字 居中 列表123- 列表1 - 列表1.1 - 列表1.2 列表1 列表1.1 列表1.2 链接以及图片123[少数派](https://sspai.com/)![logo](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2634294714,2265844648&amp;fm=58&amp;s=4EE6885691B0CD92947DB9F002005035&amp;bpow=121&amp;bpoh=75) 少数派 表格1234大标题1|大标题2|大标题3--|--|--内容1|内容2|内容3内容1|内容2|内容3 大标题1 大标题2 大标题3 内容1 内容2 内容3 内容1 内容2 内容3 插入图片 大小设置12方案一：默认大小 ![](/images/Desert.jpg) 方案二：设置大小 &lt;img width=400 src=&quot;/images/Desert.jpg&quot; &gt;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonUtils]]></title>
    <url>%2F2019%2F08%2F27%2FjsonUtils%2F</url>
    <content type="text"><![CDATA[jsonUtil工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.zzcm.shortvideospider.util;import com.fasterxml.jackson.core.JsonParseException;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.text.SimpleDateFormat;import java.util.Map;public class JsonUtil &#123; private static final Logger logger = LoggerFactory.getLogger(JsonUtil.class); private static final ObjectMapper mapper = new ObjectMapper(); public static ObjectMapper getMapper() &#123; return mapper; &#125; public static String toJson(Object object) &#123; String json = null; try &#123; json = mapper.writeValueAsString(object); &#125; catch (JsonProcessingException var3) &#123; logger.warn(var3.getMessage(), var3); &#125; return json; &#125; /** * 功能描述: fromJson(Stinrg,List.class,Map.class) * @Author: fjk * @Date: 2019/8/27 14:00 */ public static &lt;T&gt; T fromJson(String json, Class&lt;?&gt; collectionClass, Class... elementClasses) &#123; Object t = null; try &#123; t = mapper.readValue(json, mapper.getTypeFactory().constructParametricType(collectionClass, elementClasses)); &#125; catch (Exception var5) &#123; logger.warn(var5.getMessage(), var5); &#125; return (T) t; &#125; public static &lt;T&gt; T object(String json, Class&lt;T&gt; clazz) &#123; if(StringUtils.isEmpty(json)) &#123; return null; &#125; try &#123; return mapper.readValue(json, clazz); &#125; catch (JsonParseException var3) &#123; logger.error("JsonParseException", var3); &#125; catch (RuntimeException var4) &#123; logger.error("Runtime exception " + StringUtils.abbreviate(json, 80), var4); &#125; catch (Exception var5) &#123; logger.error("Exception " + StringUtils.abbreviate(json, 80), var5); &#125; return null; &#125; public static &lt;T&gt; T object(String json, TypeReference typeReference) &#123; Object t = null; try &#123; t = mapper.readValue(json, typeReference); &#125; catch (Exception var4) &#123; logger.warn(var4.getMessage(), var4); &#125; return (T) t; &#125; public static Map&lt;String, ?&gt; getMapFromJson(String json) &#123; Map map = null; try &#123; map = (Map)mapper.readValue(json, Map.class); &#125; catch (Exception var3) &#123; logger.warn(var3.getMessage(), var3); &#125; return map; &#125; static &#123; mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); &#125;&#125; bean转json字符串1String str = JsonUtil.toJson(Bean); json字符串转一层bean1Bean bean = JsonUtil.object(String,Bean.class); json字符串转多层嵌套bean1Bean bean = JsonUtil.object(String,new TypeReference(Bean)&#123;&#125;); json字符串转Map1Map&lt;Sintrg,Objext&gt; map = JsonUtil.getMapFromJson(Bean); json字符串转List&lt;Map&lt;Sintrg,Objext&gt;&gt;1List&lt;Map&lt;Sintrg,Objext&gt;&gt; listMap = fromJson(Stinrg,List.class,Map.class);]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo bulid]]></title>
    <url>%2F2019%2F08%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: baiduMore info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo rule</tag>
      </tags>
  </entry>
</search>
