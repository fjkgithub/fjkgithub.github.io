<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java面向对象]]></title>
    <url>%2F2019%2F11%2F01%2Fjava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象的三大基本特征(1)封装 （2）继承 （3）多态 五大基本原则单一职责原则其核心思想为：一个类，最好只做一件事。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。 开放封闭原则其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。 实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。。 Liskov替换原则其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 依赖倒置原则其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 接口隔离原则其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。 值传递和引用传递值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 区别 值传递 引用传递 根本区别 会创建副本 不创建副本，使用地址 所以 函数无法改变原始对象 函数可以改变原始对象]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GsonUtils]]></title>
    <url>%2F2019%2F09%2F24%2FGsonUtils%2F</url>
    <content type="text"><![CDATA[pom.xml文件的依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; GsonUtils工具类GsonJson类自定义，可多层嵌套bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.zzcm.utils;import com.google.gson.Gson;import java.lang.reflect.Type;import java.util.List;import java.util.Map;/** * @Author: fjk * @Date: 2019/9/24 10:12 * @Description */public class GsonUtils &#123; private static Gson gson = null; static &#123; if (gson == null) &#123; gson = new Gson(); &#125; &#125; private GsonUtils() &#123; &#125; /** * 将object对象转成json字符串 * @param object * @return */ public static String toString(Object object) &#123; String gsonString = null; if (gson != null) &#123; gsonString = gson.toJson(object); &#125; return gsonString; &#125; /** * 将gsonString转成泛型bean * @param gsonString * @param cls * @return */ public static &lt;T&gt; T toBean(String gsonString, Class&lt;T&gt; cls) &#123; T t = null; if (gson != null) &#123; t = gson.fromJson(gsonString, cls); &#125; return t; &#125; /** * 将gsonString转成多层嵌套bean * @param gsonString * @param type * @return */ public static &lt;T&gt; T toBean(String gsonString, Type type) &#123; return new Gson().fromJson(gsonString, type); &#125; /** * 将gsonString转成泛型Map * bean 是多层嵌套 * @param gsonString * @param type * @return */ public static &lt;T&gt; Map&lt;String, T&gt; toMap(String gsonString, Type type) &#123; Map&lt;String, T&gt; map = new Gson().fromJson(gsonString, type); return map; &#125; /** * 转成list中有map * @param gsonString * @param type * @return */ public static &lt;T&gt; List&lt;Map&lt;String, T&gt;&gt; toListMap(String gsonString, Type type) &#123; List&lt;Map&lt;String, T&gt;&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, type); &#125; return list; &#125; /** * 转成泛型list * @param gsonString * @param type * @return */ public static &lt;T&gt; List&lt;T&gt; toList(String gsonString, Type type) &#123; List&lt;T&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, type); &#125; return list; &#125; /*public static void main(String[] args) &#123; String gsonString = ""; List&lt;GsonJson&gt; list = GsonUtils.toList(gsonString,new TypeToken&lt;List&lt;GsonJson&gt;&gt;()&#123;&#125;.getType()); List&lt;Map&lt;String,GsonJson&gt;&gt; listMaps = GsonUtils.toListMap(gsonString,new TypeToken&lt;List&lt;Map&lt;String,GsonJson&gt;&gt;&gt;()&#123;&#125;.getType()); Map&lt;String,GsonJson&gt; map = GsonUtils.toMap(gsonString,new TypeToken&lt;Map&lt;String,GsonJson&gt;&gt;()&#123;&#125;.getType()); Map&lt;String,Map&lt;String,GsonJson&gt;&gt; valueMap = GsonUtils.toMap(gsonString,new TypeToken&lt;Map&lt;String,Map&lt;String,GsonJson&gt;&gt;&gt;()&#123;&#125;.getType()); GsonJson bean = GsonUtils.toBean(gsonString,new TypeToken&lt;GsonJson&gt;()&#123;&#125;.getType()); GsonJson bean1 = GsonUtils.toBean(gsonString,GsonJson.class); &#125;*/&#125;]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成redis]]></title>
    <url>%2F2019%2F09%2F19%2Fspringboot%E9%9B%86%E6%88%90redis%2F</url>
    <content type="text"><![CDATA[项目依赖的包在pom.xml文件引入 12345&lt;!--springboot redis配置--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; RedisTemplate配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class RedisTemplateI &#123; protected RedisTemplate&lt;String, Object&gt; initRedisTemplate(String hostName, int port ,int minIdle, int maxIdle, int maxTotal, long maxWaitMillis, int indexDb) &#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); this.setJacksonSerializer(redisTemplate); redisTemplate.setConnectionFactory( connectionFactory(hostName, port, "", minIdle, maxIdle, maxTotal, indexDb, maxWaitMillis, true)); return redisTemplate; &#125; protected RedisConnectionFactory connectionFactory(String hostName, int port, String password, int minIdle, int maxIdle, int maxTotal, int index, long maxWaitMillis, boolean testOnBorrow) &#123; JedisConnectionFactory jedis = new JedisConnectionFactory(); jedis.setHostName(hostName); jedis.setPort(port); if (StringUtils.isNotEmpty(password)) &#123; jedis.setPassword(password); &#125; if (index != 0) &#123; jedis.setDatabase(index); &#125; jedis.setPoolConfig(poolCofig(minIdle, maxIdle, maxTotal, maxWaitMillis, testOnBorrow)); // 初始化连接pool jedis.afterPropertiesSet(); RedisConnectionFactory factory = jedis; System.out.println("factory==========="+factory); return factory; &#125; protected JedisPoolConfig poolCofig(int minIdle, int maxIdle, int maxTotal, long maxWaitMillis, boolean testOnBorrow) &#123; JedisPoolConfig poolCofig = new JedisPoolConfig(); poolCofig.setMaxIdle(maxIdle); poolCofig.setMaxTotal(maxTotal); poolCofig.setMinIdle(minIdle); poolCofig.setMaxWaitMillis(maxWaitMillis); poolCofig.setTestOnBorrow(testOnBorrow); return poolCofig; &#125; /** * Jackson的序列化方式 * 存redis时序列化，取出时，直接获取bean对象 * @param template */ protected void setJacksonSerializer(RedisTemplate&lt;String, Object&gt; template) &#123; Jackson2JsonRedisSerializer jacksonSerial = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSerial.setObjectMapper(om); //采用jackson序列化value template.setValueSerializer(jacksonSerial); //采用String 序列化key template.setKeySerializer(new StringRedisSerializer()); //对hash key和value序列化 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(jacksonSerial); &#125;&#125;@Configurationpublic class RedisTemplateConfig extends RedisTemplateI &#123; /** * 配置相关缓存 * @param hostName //主机地址 * @param port //端口号 * @param minIdle * @param maxIdle * @param maxActive * @param maxWaitMillis * @return */ //redis_1的0号库 @Bean(name = "redisTemplate_0") public RedisTemplate&lt;String, Object&gt; redisTemplate0(@Value("$&#123;spring.redis.host_0&#125;")String hostName, @Value("$&#123;spring.redis.port_0&#125;") int port, @Value("$&#123;spring.redis.pool.min-idle_0&#125;") int minIdle, @Value("$&#123;spring.redis.pool.max-idle_0&#125;") int maxIdle, @Value("$&#123;spring.redis.pool.max-active_0&#125;") int maxActive, @Value("$&#123;spring.redis.pool.max-wait_0&#125;") long maxWaitMillis) &#123; return initRedisTemplate(hostName, port, minIdle, maxIdle,maxActive, maxWaitMillis, 0); &#125; //redis_2的0号库 @Bean(name = "redisTemplate_1") public RedisTemplate&lt;String, Object&gt; redisTemplate1(@Value("$&#123;spring.redis.host_1&#125;")String hostName, @Value("$&#123;spring.redis.port_1&#125;") int port, @Value("$&#123;spring.redis.pool.min-idle_1&#125;") int minIdle, @Value("$&#123;spring.redis.pool.max-idle_1&#125;") int maxIdle, @Value("$&#123;spring.redis.pool.max-active_1&#125;") int maxActive, @Value("$&#123;spring.redis.pool.max-wait_1&#125;") long maxWaitMillis) &#123; return initRedisTemplate(hostName, port, minIdle, maxIdle, maxActive, maxWaitMillis, 0); &#125; //redis_2的1号库 @Bean(name = "redisTemplate_1") public RedisTemplate&lt;String, Object&gt; redisTemplate1(@Value("$&#123;spring.redis.host_1&#125;")String hostName, @Value("$&#123;spring.redis.port_1&#125;") int port, @Value("$&#123;spring.redis.pool.min-idle_1&#125;") int minIdle, @Value("$&#123;spring.redis.pool.max-idle_1&#125;") int maxIdle, @Value("$&#123;spring.redis.pool.max-active_1&#125;") int maxActive, @Value("$&#123;spring.redis.pool.max-wait_1&#125;") long maxWaitMillis) &#123; return initRedisTemplate(hostName, port, minIdle, maxIdle, maxActive, maxWaitMillis, 1); &#125;&#125; application.properties文件添加12345678spring.redis.host_0 = 192.168.0.221spring.redis.port_0 = 6379spring.redis.timeout_0 = 30000spring.redis.pool.max-active_0 = 8spring.redis.pool.max-wait_0 = -1spring.redis.pool.max-idle_0 = 8spring.redis.pool.min-idle_0 = 1` AbsRedisTemplate工具类的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349package com.zzcm.system.utils;import org.springframework.data.redis.connection.DataType;import org.springframework.data.redis.core.Cursor;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ScanOptions;import org.springframework.data.redis.core.ZSetOperations.TypedTuple;import java.util.*;import java.util.Map.Entry;import java.util.concurrent.TimeUnit;/** * @Author: fjk * @Date: 2019/9/29 16:05 * @Description */public abstract class AbsRedisTemplate &#123; protected abstract RedisTemplate getRedisTemplate();/** -------------------key相关操作--------------------- */ /** * 删除key * * @param key */ public void delete(String key) &#123; getRedisTemplate().delete(key); &#125; /** * 批量删除key * * @param keys */ public void delete(Collection&lt;String&gt; keys) &#123; getRedisTemplate().delete(keys); &#125; /** * 序列化key * * @param key * @return */ public byte[] dump(String key) &#123; return getRedisTemplate().dump(key); &#125; /** * 是否存在key * * @param key * @return */ public Boolean hasKey(String key) &#123; return getRedisTemplate().hasKey(key); &#125; /** * 设置过期时间 * * @param key * @param timeout * @param unit * @return */ public Boolean expire(String key, long timeout, TimeUnit unit) &#123; return getRedisTemplate().expire(key, timeout, unit); &#125; /** * 设置过期时间 * * @param key * @param date * @return */ public Boolean expireAt(String key, Date date) &#123; return getRedisTemplate().expireAt(key, date); &#125; /** * 查找匹配的key * * @param pattern * @return */ public Set&lt;String&gt; keys(String pattern) &#123; return getRedisTemplate().keys(pattern); &#125; /** * 将当前数据库的 key 移动到给定的数据库 db 当中 * * @param key * @param dbIndex * @return */ public Boolean move(String key, int dbIndex) &#123; return getRedisTemplate().move(key, dbIndex); &#125; /** * 移除 key 的过期时间，key 将持久保持 * * @param key * @return */ public Boolean persist(String key) &#123; return getRedisTemplate().persist(key); &#125; /** * 返回 key 的剩余的过期时间 * * @param key * @param unit * @return */ public Long getExpire(String key, TimeUnit unit) &#123; return getRedisTemplate().getExpire(key, unit); &#125; /** * 返回 key 的剩余的过期时间 * * @param key * @return */ public Long getExpire(String key) &#123; return getRedisTemplate().getExpire(key); &#125; /** * 从当前数据库中随机返回一个 key * * @return */ public Object randomKey() &#123; return getRedisTemplate().randomKey(); &#125; /** * 修改 key 的名称 * * @param oldKey * @param newKey */ public void rename(String oldKey, String newKey) &#123; getRedisTemplate().rename(oldKey, newKey); &#125; /** * 仅当 newkey 不存在时，将 oldKey 改名为 newkey * * @param oldKey * @param newKey * @return */ public Boolean renameIfAbsent(String oldKey, String newKey) &#123; return getRedisTemplate().renameIfAbsent(oldKey, newKey); &#125; /** * 返回 key 所储存的值的类型 * * @param key * @return */ public DataType type(String key) &#123; return getRedisTemplate().type(key); &#125; /** -------------------string相关操作--------------------- */ /** * 设置指定 key 的值 * @param key * @param value */ public void set(String key, String value) &#123; getRedisTemplate().opsForValue().set(key, value); &#125; /** * 获取指定 key 的值 * @param key * @return */ public Object get(String key) &#123; return getRedisTemplate().opsForValue().get(key); &#125; /** * 返回 key 中字符串值的子字符 * @param key * @param start * @param end * @return */ public String getRange(String key, long start, long end) &#123; return getRedisTemplate().opsForValue().get(key, start, end); &#125; /** * 将给定 key 的值设为 value ，并返回 key 的旧值(old value) * * @param key * @param value * @return */ public Object getAndSet(String key, String value) &#123; return getRedisTemplate().opsForValue().getAndSet(key, value); &#125; /** * 对 key 所储存的字符串值，获取指定偏移量上的位(bit) * * @param key * @param offset * @return */ public Boolean getBit(String key, long offset) &#123; return getRedisTemplate().opsForValue().getBit(key, offset); &#125; /** * 批量获取 * * @param keys * @return */ public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) &#123; return getRedisTemplate().opsForValue().multiGet(keys); &#125; /** * 设置ASCII码, 字符串'a'的ASCII码是97, 转为二进制是'01100001', 此方法是将二进制第offset位值变为value * * @param key * @param offset * 位置 * @param value * 值,true为1, false为0 * @return */ public boolean setBit(String key, long offset, boolean value) &#123; return getRedisTemplate().opsForValue().setBit(key, offset, value); &#125; /** * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout * * @param key * @param value * @param timeout * 过期时间 * @param unit * 时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES * 秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS */ public void setEx(String key, String value, long timeout, TimeUnit unit) &#123; getRedisTemplate().opsForValue().set(key, value, timeout, unit); &#125; /** * 只有在 key 不存在时设置 key 的值 * * @param key * @param value * @return 之前已经存在返回false,不存在返回true */ public boolean setIfAbsent(String key, String value) &#123; return getRedisTemplate().opsForValue().setIfAbsent(key, value); &#125; /** * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始 * * @param key * @param value * @param offset * 从指定位置开始覆写 */ public void setRange(String key, String value, long offset) &#123; getRedisTemplate().opsForValue().set(key, value, offset); &#125; /** * 获取字符串的长度 * * @param key * @return */ public Long size(String key) &#123; return getRedisTemplate().opsForValue().size(key); &#125; /** * 批量添加 * * @param maps */ public void multiSet(Map&lt;String, String&gt; maps) &#123; getRedisTemplate().opsForValue().multiSet(maps); &#125; /** * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 * * @param maps * @return 之前已经存在返回false,不存在返回true */ public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) &#123; return getRedisTemplate().opsForValue().multiSetIfAbsent(maps); &#125; /** * 增加(自增长), 负数则为自减 * * @param key * @param increment * @return */ public Long incrBy(String key, long increment) &#123; return getRedisTemplate().opsForValue().increment(key, increment); &#125; /** * * @param key * @param increment * @return */ public Double incrByFloat(String key, double increment) &#123; return getRedisTemplate().opsForValue().increment(key, increment); &#125; /** * 追加到末尾 * * @param key * @param value * @return */ public Integer append(String key, String value) &#123; return getRedisTemplate().opsForValue().append(key, value); &#125; /** -------------------hash相关操作------------------------- */ /** * 获取存储在哈希表中指定字段的值 * * @param key * @param field * @return */ public Object hGet(String key, String field) &#123; return getRedisTemplate().opsForHash().get(key, field); &#125; /** * 获取所有给定字段的值 * * @param key * @return */ public Map&lt;Object, Object&gt; hGetAll(String key) &#123; return getRedisTemplate().opsForHash().entries(key); &#125; /** * 获取所有给定字段的值 * * @param key * @param fields * @return */ public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) &#123; return getRedisTemplate().opsForHash().multiGet(key, fields); &#125; public void hPut(String key, String hashKey, String value) &#123; getRedisTemplate().opsForHash().put(key, hashKey, value); &#125; public void hPutAll(String key, Map&lt;String, String&gt; maps) &#123; getRedisTemplate().opsForHash().putAll(key, maps); &#125; /** * 仅当hashKey不存在时才设置 * * @param key * @param hashKey * @param value * @return */ public Boolean hPutIfAbsent(String key, String hashKey, String value) &#123; return getRedisTemplate().opsForHash().putIfAbsent(key, hashKey, value); &#125; /** * 删除一个或多个哈希表字段 * * @param key * @param fields * @return */ public Long hDelete(String key, Object... fields) &#123; return getRedisTemplate().opsForHash().delete(key, fields); &#125; /** * 查看哈希表 key 中，指定的字段是否存在 * * @param key * @param field * @return */ public boolean hExists(String key, String field) &#123; return getRedisTemplate().opsForHash().hasKey(key, field); &#125; /** * 为哈希表 key 中的指定字段的整数值加上增量 increment * * @param key * @param field * @param increment * @return */ public Long hIncrBy(String key, Object field, long increment) &#123; return getRedisTemplate().opsForHash().increment(key, field, increment); &#125; /** * 为哈希表 key 中的指定字段的整数值加上增量 increment * * @param key * @param field * @param delta * @return */ public Double hIncrByFloat(String key, Object field, double delta) &#123; return getRedisTemplate().opsForHash().increment(key, field, delta); &#125; /** * 获取所有哈希表中的字段 * * @param key * @return */ public Set&lt;Object&gt; hKeys(String key) &#123; return getRedisTemplate().opsForHash().keys(key); &#125; /** * 获取哈希表中字段的数量 * * @param key * @return */ public Long hSize(String key) &#123; return getRedisTemplate().opsForHash().size(key); &#125; /** * 获取哈希表中所有值 * * @param key * @return */ public List&lt;Object&gt; hValues(String key) &#123; return getRedisTemplate().opsForHash().values(key); &#125; /** * 迭代哈希表中的键值对 * * @param key * @param options * @return */ public Cursor&lt;Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) &#123; return getRedisTemplate().opsForHash().scan(key, options); &#125; /** ------------------------list相关操作---------------------------- */ /** * 通过索引获取列表中的元素 * * @param key * @param index * @return */ public Object lIndex(String key, long index) &#123; return getRedisTemplate().opsForList().index(key, index); &#125; /** * 获取列表指定范围内的元素 * * @param key * @param start * 开始位置, 0是开始位置 * @param end * 结束位置, -1返回所有 * @return */ public List&lt;String&gt; lRange(String key, long start, long end) &#123; return getRedisTemplate().opsForList().range(key, start, end); &#125; /** * 存储在list头部 * * @param key * @param value * @return */ public Long lLeftPush(String key, String value) &#123; return getRedisTemplate().opsForList().leftPush(key, value); &#125; /** * * @param key * @param value * @return */ public Long lLeftPushAll(String key, String... value) &#123; return getRedisTemplate().opsForList().leftPushAll(key, value); &#125; /** * * @param key * @param value * @return */ public Long lLeftPushAll(String key, Collection&lt;String&gt; value) &#123; return getRedisTemplate().opsForList().leftPushAll(key, value); &#125; /** * 当list存在的时候才加入 * * @param key * @param value * @return */ public Long lLeftPushIfPresent(String key, String value) &#123; return getRedisTemplate().opsForList().leftPushIfPresent(key, value); &#125; /** * 如果pivot存在,再pivot前面添加 * * @param key * @param pivot * @param value * @return */ public Long lLeftPush(String key, String pivot, String value) &#123; return getRedisTemplate().opsForList().leftPush(key, pivot, value); &#125; /** * * @param key * @param value * @return */ public Long lRightPush(String key, String value) &#123; return getRedisTemplate().opsForList().rightPush(key, value); &#125; /** * * @param key * @param value * @return */ public Long lRightPushAll(String key, String... value) &#123; return getRedisTemplate().opsForList().rightPushAll(key, value); &#125; /** * * @param key * @param value * @return */ public Long lRightPushAll(String key, Collection&lt;String&gt; value) &#123; return getRedisTemplate().opsForList().rightPushAll(key, value); &#125; /** * 为已存在的列表添加值 * * @param key * @param value * @return */ public Long lRightPushIfPresent(String key, String value) &#123; return getRedisTemplate().opsForList().rightPushIfPresent(key, value); &#125; /** * 在pivot元素的右边添加值 * * @param key * @param pivot * @param value * @return */ public Long lRightPush(String key, String pivot, String value) &#123; return getRedisTemplate().opsForList().rightPush(key, pivot, value); &#125; /** * 通过索引设置列表元素的值 * * @param key * @param index * 位置 * @param value */ public void lSet(String key, long index, String value) &#123; getRedisTemplate().opsForList().set(key, index, value); &#125; /** * 移出并获取列表的第一个元素 * * @param key * @return 删除的元素 */ public Object lLeftPop(String key) &#123; return getRedisTemplate().opsForList().leftPop(key); &#125; /** * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param key * @param timeout * 等待时间 * @param unit * 时间单位 * @return */ public Object lBLeftPop(String key, long timeout, TimeUnit unit) &#123; return getRedisTemplate().opsForList().leftPop(key, timeout, unit); &#125; /** * 移除并获取列表最后一个元素 * * @param key * @return 删除的元素 */ public Object lRightPop(String key) &#123; return getRedisTemplate().opsForList().rightPop(key); &#125; /** * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param key * @param timeout * 等待时间 * @param unit * 时间单位 * @return */ public Object lBRightPop(String key, long timeout, TimeUnit unit) &#123; return getRedisTemplate().opsForList().rightPop(key, timeout, unit); &#125; /** * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 * * @param sourceKey * @param destinationKey * @return */ public Object lRightPopAndLeftPush(String sourceKey, String destinationKey) &#123; return getRedisTemplate().opsForList().rightPopAndLeftPush(sourceKey, destinationKey); &#125; /** * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param sourceKey * @param destinationKey * @param timeout * @param unit * @return */ public Object lBRightPopAndLeftPush(String sourceKey, String destinationKey, long timeout, TimeUnit unit) &#123; return getRedisTemplate().opsForList().rightPopAndLeftPush(sourceKey, destinationKey, timeout, unit); &#125; /** * 删除集合中值等于value得元素 * * @param key * @param index * index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素; * index&lt;0, 从尾部开始删除第一个值等于value的元素; * @param value * @return */ public Long lRemove(String key, long index, String value) &#123; return getRedisTemplate().opsForList().remove(key, index, value); &#125; /** * 裁剪list * * @param key * @param start * @param end */ public void lTrim(String key, long start, long end) &#123; getRedisTemplate().opsForList().trim(key, start, end); &#125; /** * 获取列表长度 * * @param key * @return */ public Long lLen(String key) &#123; return getRedisTemplate().opsForList().size(key); &#125; /** --------------------set相关操作-------------------------- */ /** * set添加元素 * * @param key * @param values * @return */ public Long sAdd(String key, String... values) &#123; return getRedisTemplate().opsForSet().add(key, values); &#125; /** * set移除元素 * * @param key * @param values * @return */ public Long sRemove(String key, Object... values) &#123; return getRedisTemplate().opsForSet().remove(key, values); &#125; /** * 移除并返回集合的一个随机元素 * * @param key * @return */ public Object sPop(String key) &#123; return getRedisTemplate().opsForSet().pop(key); &#125; /** * 将元素value从一个集合移到另一个集合 * * @param key * @param value * @param destKey * @return */ public Boolean sMove(String key, String value, String destKey) &#123; return getRedisTemplate().opsForSet().move(key, value, destKey); &#125; /** * 获取集合的大小 * * @param key * @return */ public Long sSize(String key) &#123; return getRedisTemplate().opsForSet().size(key); &#125; /** * 判断集合是否包含value * * @param key * @param value * @return */ public Boolean sIsMember(String key, Object value) &#123; return getRedisTemplate().opsForSet().isMember(key, value); &#125; /** * 获取两个集合的交集 * * @param key * @param otherKey * @return */ public Set&lt;String&gt; sIntersect(String key, String otherKey) &#123; return getRedisTemplate().opsForSet().intersect(key, otherKey); &#125; /** * 获取key集合与多个集合的交集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) &#123; return getRedisTemplate().opsForSet().intersect(key, otherKeys); &#125; /** * key集合与otherKey集合的交集存储到destKey集合中 * * @param key * @param otherKey * @param destKey * @return */ public Long sIntersectAndStore(String key, String otherKey, String destKey) &#123; return getRedisTemplate().opsForSet().intersectAndStore(key, otherKey, destKey); &#125; /** * key集合与多个集合的交集存储到destKey集合中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return getRedisTemplate().opsForSet().intersectAndStore(key, otherKeys, destKey); &#125; /** * 获取两个集合的并集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sUnion(String key, String otherKeys) &#123; return getRedisTemplate().opsForSet().union(key, otherKeys); &#125; /** * 获取key集合与多个集合的并集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) &#123; return getRedisTemplate().opsForSet().union(key, otherKeys); &#125; /** * key集合与otherKey集合的并集存储到destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long sUnionAndStore(String key, String otherKey, String destKey) &#123; return getRedisTemplate().opsForSet().unionAndStore(key, otherKey, destKey); &#125; /** * key集合与多个集合的并集存储到destKey中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return getRedisTemplate().opsForSet().unionAndStore(key, otherKeys, destKey); &#125; /** * 获取两个集合的差集 * * @param key * @param otherKey * @return */ public Set&lt;String&gt; sDifference(String key, String otherKey) &#123; return getRedisTemplate().opsForSet().difference(key, otherKey); &#125; /** * 获取key集合与多个集合的差集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) &#123; return getRedisTemplate().opsForSet().difference(key, otherKeys); &#125; /** * key集合与otherKey集合的差集存储到destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long sDifference(String key, String otherKey, String destKey) &#123; return getRedisTemplate().opsForSet().differenceAndStore(key, otherKey, destKey); &#125; /** * key集合与多个集合的差集存储到destKey中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sDifference(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return getRedisTemplate().opsForSet().differenceAndStore(key, otherKeys, destKey); &#125; /** * 获取集合所有元素 * * @param key * @return */ public Set&lt;String&gt; setMembers(String key) &#123; return getRedisTemplate().opsForSet().members(key); &#125; /** * 随机获取集合中的一个元素 * * @param key * @return */ public Object sRandomMember(String key) &#123; return getRedisTemplate().opsForSet().randomMember(key); &#125; /** * 随机获取集合中count个元素 * * @param key * @param count * @return */ public List&lt;String&gt; sRandomMembers(String key, long count) &#123; return getRedisTemplate().opsForSet().randomMembers(key, count); &#125; /** * 随机获取集合中count个元素并且去除重复的 * * @param key * @param count * @return */ public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) &#123; return getRedisTemplate().opsForSet().distinctRandomMembers(key, count); &#125; /** * * @param key * @param options * @return */ public Cursor&lt;String&gt; sScan(String key, ScanOptions options) &#123; return getRedisTemplate().opsForSet().scan(key, options); &#125; /**------------------zSet相关操作--------------------------------*/ /** * 添加元素,有序集合是按照元素的score值由小到大排列 * * @param key * @param value * @param score * @return */ public Boolean zAdd(String key, String value, double score) &#123; return getRedisTemplate().opsForZSet().add(key, value, score); &#125; /** * * @param key * @param values * @return */ public Long zAdd(String key, Set&lt;TypedTuple&lt;String&gt;&gt; values) &#123; return getRedisTemplate().opsForZSet().add(key, values); &#125; /** * * @param key * @param values * @return */ public Long zRemove(String key, Object... values) &#123; return getRedisTemplate().opsForZSet().remove(key, values); &#125; /** * 增加元素的score值，并返回增加后的值 * * @param key * @param value * @param delta * @return */ public Double zIncrementScore(String key, String value, double delta) &#123; return getRedisTemplate().opsForZSet().incrementScore(key, value, delta); &#125; /** * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列 * * @param key * @param value * @return 0表示第一位 */ public Long zRank(String key, Object value) &#123; return getRedisTemplate().opsForZSet().rank(key, value); &#125; /** * 返回元素在集合的排名,按元素的score值由大到小排列 * * @param key * @param value * @return */ public Long zReverseRank(String key, Object value) &#123; return getRedisTemplate().opsForZSet().reverseRank(key, value); &#125; /** * 获取集合的元素, 从小到大排序 * * @param key * @param start * 开始位置 * @param end * 结束位置, -1查询所有 * @return */ public Set&lt;String&gt; zRange(String key, long start, long end) &#123; return getRedisTemplate().opsForZSet().range(key, start, end); &#125; /** * 获取集合元素, 并且把score值也获取 * * @param key * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start, long end) &#123; return getRedisTemplate().opsForZSet().rangeWithScores(key, start, end); &#125; /** * 根据Score值查询集合元素 * * @param key * @param min * 最小值 * @param max * 最大值 * @return */ public Set&lt;String&gt; zRangeByScore(String key, double min, double max) &#123; return getRedisTemplate().opsForZSet().rangeByScore(key, min, max); &#125; /** * 根据Score值查询集合元素, 从小到大排序 * * @param key * @param min * 最小值 * @param max * 最大值 * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, double min, double max) &#123; return getRedisTemplate().opsForZSet().rangeByScoreWithScores(key, min, max); &#125; /** * * @param key * @param min * @param max * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, double min, double max, long start, long end) &#123; return getRedisTemplate().opsForZSet().rangeByScoreWithScores(key, min, max, start, end); &#125; /** * 获取集合的元素, 从大到小排序 * * @param key * @param start * @param end * @return */ public Set&lt;String&gt; zReverseRange(String key, long start, long end) &#123; return getRedisTemplate().opsForZSet().reverseRange(key, start, end); &#125; /** * 获取集合的元素, 从大到小排序, 并返回score值 * * @param key * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key, long start, long end) &#123; return getRedisTemplate().opsForZSet().reverseRangeWithScores(key, start, end); &#125; /** * 根据Score值查询集合元素, 从大到小排序 * * @param key * @param min * @param max * @return */ public Set&lt;String&gt; zReverseRangeByScore(String key, double min, double max) &#123; return getRedisTemplate().opsForZSet().reverseRangeByScore(key, min, max); &#125; /** * 根据Score值查询集合元素, 从大到小排序 * * @param key * @param min * @param max * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores( String key, double min, double max) &#123; return getRedisTemplate().opsForZSet().reverseRangeByScoreWithScores(key, min, max); &#125; /** * * @param key * @param min * @param max * @param start * @param end * @return */ public Set&lt;String&gt; zReverseRangeByScore(String key, double min, double max, long start, long end) &#123; return getRedisTemplate().opsForZSet().reverseRangeByScore(key, min, max, start, end); &#125; /** * 根据score值获取集合元素数量 * * @param key * @param min * @param max * @return */ public Long zCount(String key, double min, double max) &#123; return getRedisTemplate().opsForZSet().count(key, min, max); &#125; /** * 获取集合大小 * * @param key * @return */ public Long zSize(String key) &#123; return getRedisTemplate().opsForZSet().size(key); &#125; /** * 获取集合大小 * * @param key * @return */ public Long zZCard(String key) &#123; return getRedisTemplate().opsForZSet().zCard(key); &#125; /** * 获取集合中value元素的score值 * * @param key * @param value * @return */ public Double zScore(String key, Object value) &#123; return getRedisTemplate().opsForZSet().score(key, value); &#125; /** * 移除指定索引位置的成员 * * @param key * @param start * @param end * @return */ public Long zRemoveRange(String key, long start, long end) &#123; return getRedisTemplate().opsForZSet().removeRange(key, start, end); &#125; /** * 根据指定的score值的范围来移除成员 * * @param key * @param min * @param max * @return */ public Long zRemoveRangeByScore(String key, double min, double max) &#123; return getRedisTemplate().opsForZSet().removeRangeByScore(key, min, max); &#125; /** * 获取key和otherKey的并集并存储在destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long zUnionAndStore(String key, String otherKey, String destKey) &#123; return getRedisTemplate().opsForZSet().unionAndStore(key, otherKey, destKey); &#125; /** * * @param key * @param otherKeys * @param destKey * @return */ public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return getRedisTemplate().opsForZSet() .unionAndStore(key, otherKeys, destKey); &#125; /** * 交集 * * @param key * @param otherKey * @param destKey * @return */ public Long zIntersectAndStore(String key, String otherKey, String destKey) &#123; return getRedisTemplate().opsForZSet().intersectAndStore(key, otherKey, destKey); &#125; /** * 交集 * * @param key * @param otherKeys * @param destKey * @return */ public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return getRedisTemplate().opsForZSet().intersectAndStore(key, otherKeys, destKey); &#125; /** * * @param key * @param options * @return */ public Cursor&lt;TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) &#123; return getRedisTemplate().opsForZSet().scan(key, options); &#125;&#125; RedisTemplateImpl实现类1234567891011@Componentpublic class RedisTemplateImpl extends AbsRedisTemplate &#123; @Resource(name = "redisTemplate_1") private RedisTemplate redisTemplate; @Override protected RedisTemplate getRedisTemplate() &#123; return redisTemplate; &#125;&#125; redis工具类的使用12345678910111213@Autowired private RedisTemplateImpl redisTemplateImpl; String key = "key"; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("1","111"); map.put("2","222"); map.put("3","333"); redisTemplateImpl2.hPutAll(key,map); Map&lt;Object, Object&gt; map1 = redisTemplateImpl2.hGetAll(key); redisTemplateImpl2.expire(key,5L, TimeUnit.SECONDS); Map&lt;Object, Object&gt; map2 = redisTemplateImpl2.hGetAll(key); System.out.println(map2);]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql表建分区]]></title>
    <url>%2F2019%2F09%2F19%2Fmysql%E8%A1%A8%E5%BB%BA%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[建表同时创建分区TO_DAYS(date),每天一个分区。date字段一定要是索引 12345678910111213141516CREATE TABLE `user_stats_data` (`time_id` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,`app_id` BIGINT(20) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;应用id&apos;,`uid` VARCHAR(50) NOT NULL,`date` DATE NOT NULL COMMENT &apos;日期&apos;,`dimension` VARCHAR(255) NOT NULL,`EPBCODE` INT(11) DEFAULT &apos;0&apos; COMMENT &apos;书籍曝光&apos;,`BCODE` INT(11) DEFAULT &apos;0&apos; COMMENT &apos;书籍点击&apos;,UNIQUE KEY `unique_key` (`app_id`,`uid`,`date`,`dimension`),KEY `date_state_uid_date` (`uid`,`date`,`dimension`),KEY `date_type` (`date`,`dimension`) USING BTREE,KEY `date_index` (`date`) USING HASH) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT=&apos;用户操作节点uid按天汇总表&apos;PARTITION BY RANGE (TO_DAYS(`date`))(PARTITION p20190628 VALUES LESS THAN (TO_DAYS(&apos;2019-06-29&apos;)) ENGINE = INNODB,PARTITION p20190629 VALUES LESS THAN (TO_DAYS(&apos;2019-06-30&apos;)) ENGINE = INNODB); 定时任务每天创建后三天的表分区123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CreateDayPartitonJob &#123; private String table; private String partitonSql; @Resource(name = "buzJdbcTemplate") private JdbcTemplate jdbc; @Scheduled(cron = "0 0 1 * * ?") @PostConstruct public void execute() &#123; //书籍活跃留存统计分区表 table = "app_retention_day_stats"; partitonSql = "ALTER TABLE `%s` ADD PARTITION(PARTITION p%s VALUES LESS THAN (TO_DAYS('%s')) ENGINE = INNODB);"; createPartiton(table,partitonSql,jdbc); &#125; public void createPartiton(String table,String sql,JdbcTemplate jdbcTemplate)&#123; log.info("检测表是否存..."); boolean isExe = isTable(table,jdbcTemplate); log.info("表情况[若true,则结束.]:"+isExe); if(!isExe)&#123; log.warn("警告：表不存在:"+table); return; &#125; String afterZeroDay = DateUtil.getBeforeOrAfterDays(DateUtil.YYYYMMDD,0); String afterOneDay = DateUtil.getBeforeOrAfterDays(DateUtil.YYYYMMDD,1); String afterTwoDay = DateUtil.getBeforeOrAfterDays(DateUtil.YYYYMMDD,2); String afterThreeDay = DateUtil.getBeforeOrAfterDays(DateUtil.YYYYMMDD,3); createPartiton(table,sql,afterZeroDay,afterOneDay,jdbcTemplate); createPartiton(table,sql,afterOneDay,afterTwoDay,jdbcTemplate); createPartiton(table,sql,afterTwoDay,afterThreeDay,jdbcTemplate); &#125; private void createPartiton(String table,String partitonSql,String afterDay,String afterTeoDay,JdbcTemplate jdbcTemplate) &#123; try &#123; log.info("准备创建分区."); //检查分区是否存在 boolean isExits = isPartiton(table,afterDay,jdbcTemplate); if (isExits)&#123; log.info("table=&#123;&#125;，p=&#123;&#125;以存在该分区",table,afterDay); return; &#125; String exe = String.format(partitonSql,table,afterDay,afterTeoDay); log.info("准备执行..."); int num = jdbcTemplate.update(exe); log.info("执行完成，影响行数:" + num ); &#125; catch (Exception e) &#123; log.error("创建:`"+table+"`表分区失败",e); &#125; &#125; public boolean isTable(String table,JdbcTemplate jdbc)&#123; List list = jdbc.queryForList(String.format("SHOW TABLES LIKE '%s' ",table)); if(list != null &amp;&amp; list.size() == 1) &#123; return true; &#125; return false; &#125; public boolean isPartiton(String table,String date,JdbcTemplate jdbcTemplate)&#123; String sql ="SELECT partition_name part FROM information_schema.partitions WHERE " + " table_schema = SCHEMA() AND table_name='%s' AND partition_name = '%s' "; List list = jdbcTemplate.queryForList(String.format(sql,table,'p'+date)); if(list != null &amp;&amp; list.size() == 1) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql表字段支持emoji表情]]></title>
    <url>%2F2019%2F09%2F19%2Fmysql%E8%A1%A8%E5%AD%97%E6%AE%B5%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[修改字段,或者表的编码格式一般我们数据编码格式默认设置为utf-8, 但是utf-8并不支持表情,而表情需要utf8mb4编码格式 123451、修改表的字符集：ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 2、修改字段的字符集：ALTER TABLE table_name CHANGE column_name column_name VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 修改mysql连接池12345spring.datasource.jdbc-url=jdbc:mysql://192.168.0.223:3306/iadmoviesupport?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNullspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.connection-init-sql=set names utf8mb4]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>emoji表情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx搭建和配置]]></title>
    <url>%2F2019%2F09%2F19%2Fnginx%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[nginx安装1、下载nginx1$ wget http://nginx.org/download/nginx-1.9.2.tar.gz 2、安装环境123$ yum install pcre.x86_64 pcre-devel.x86_64 -y$ yum install gcc gcc-c++ -y$ yum install zlib-devel.x86_64 zlib.x86_64 -y 3、解压编译安装1234$ tar -zvxf nginx-1.9.2.tar.gz -C /usr/local/$ cd /usr/local/nginx-1.9.2/$ ./configure --prefix=/usr/local/nginx --with-pcre --user=daemon --group=daemon --with-http_stub_status_module$ make -j4 &amp;&amp; make install 为了方便执行，设置软链接。就可以直接./nginx直接启动nginx 1$ ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/ 4、启动、查看版本、重启、关闭1234$ cd /usr/local/sbin目录下 ./nginx $ cd /usr/local/sbin目录下 ./nginx -v$ cd/usr/nginx/sbin目录下 ./nginx -s reload$ cd/usr/nginx/sbin目录下 ./nginx -s stop nginx配置1、挂载目录直接修改listen端口，和root配置的文件目录，其中文件目录要修改权限chmod 777 -R dirName。修改完成后，直接重启nginx。访问机器ip:8060就是直接挂载到/home/ad目录。可以直接访问/home/ad目录下的静态文件。 12345678910server &#123; listen 8060; server_name localhost; location ~ .*\.(ico)$ &#123; access_log off; log_not_found off; &#125; root /home/ad;&#125; 关闭防火墙当NG访问不到时，要看是不是没有开启NG，或者重新开启，如果再访问不了，就看一下防火墙有没有关。 123$ systemctl stop firewalld.service$ firewall-cmd --state #查看防火墙状态 not running表示关闭$ systemctl disable firewalld.service #禁止firewall开机启动 查看nginx监听的端口服务1$ netstat -anptu |grep nginx 显示结果：有三个端口 123tcp 0 0 0.0.0.0:5999 0.0.0.0:* LISTEN 3680/nginx: master tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 3680/nginx: master tcp 0 0 0.0.0.0:8060 0.0.0.0:* LISTEN 3680/nginx: master nginx负载均衡的配置配置文件：nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#/定义Nginx运行的用户和用户组 user www www;#nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8;worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;#全局错误日志定义类型error_log /home/www/nginx_logs/error.log warn;#一个nginx进程打开的最多文件描述符数目worker_rlimit_nofile 65536;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 65536;&#125;#设定http服务器 http &#123; include mime.types;#文件扩展名与文件类型映射表 default_type application/octet-stream;#默认文件类型 server_names_hash_bucket_size 128;#服务器名字的hash表大小 keepalive_timeout 10; client_header_buffer_size 4k; #上传文件大小限制 large_client_header_buffers 8 1024k;#设定请求缓 client_header_timeout 3m; client_body_timeout 3m; send_timeout 3m; connection_pool_size 256; request_pool_size 4k; output_buffers 16 128k; postpone_output 1460; open_file_cache max=65536 inactive=20s; open_file_cache_min_uses 1; open_file_cache_valid 30s; tcp_nodelay on; sendfile on; gzip on;#开启gzip压缩输出 gzip_disable &quot;MSIE [1-5]&quot;; gzip_comp_level 3;#压缩等级 gzip_min_length 1k;#最小压缩文件大小 gzip_buffers 4 16k;#压缩缓冲区 #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_types text/plain application/x-javascript application/javascript text/css application/xml; gzip_vary on; server_name_in_redirect off; log_format access &apos;$remote_addr $remote_user - [$time_local] &quot;$request&quot; &apos; &apos;$status send=$body_bytes_sent gzip=$gzip_ratio &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;#引入proxy_pass.conf配置文件的内容include /usr/local/nginx/conf/proxy_pass.conf;&#125; 配置文件：proxy_pass.conf1234567891011121314151617181920212223242526272829303132333435363738#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大upstream rop-statistics&#123; #每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。当后台服务器宕机时，会自动跳转到其它服务器 ip_hash; server 127.0.0.1:8760; server 127.0.0.1:8761; &#125;server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name statistics.timehanju.com; #对 &quot;/&quot; 启用反向代理 location / &#123; #解决跨域问题 add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot; always; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos; always; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, OPTIONS&apos; always; add_header &apos;Access-Control-Allow-Headers&apos; &apos;Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With&apos; always; proxy_pass http://rop-statistics; proxy_cache_valid 200 304 12h; proxy_cache_key $host$uri$is_args$args; #允许客户端请求的最大单文件字节数 client_max_body_size 160m; #定义本虚拟主机的访问日志 access_log /home/ad/logs/statistics.timehanju.com.access.log access; error_log /home/ad/logs/statistics.timehanju.com.error.log error; &#125; error_page 403 404 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[easyExcel导入导出]]></title>
    <url>%2F2019%2F09%2F18%2FeasyExcel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[依赖的jar包pom.xml导入依赖包 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@Slf4jpublic class ExportExcel &#123; /** * fileName: 表明 * keys：字段 * Map&lt;String, Object&gt;map：字段对应的值 * titleList：表头 * List&lt;Map&lt;String, Object&gt;&gt; mapList：所有对象的字段对应的值 */ public static void contextLoads(HttpServletResponse response, String fileName,List&lt;String&gt; keys, List&lt;String&gt; titleList,List&lt;Map&lt;String, Object&gt;&gt; mapList) &#123; // 文件输出位置 OutputStream out = null; try &#123; // 取得输出流 out = response.getOutputStream(); // 中文文件名问题 String attachment = new String(("attachment;filename=" + fileName + ".xlsx").getBytes("UTF-8"), "ISO8859-1"); // 清空输出流 response.reset(); // 设定输出文件头 response.setHeader("Content-disposition", attachment); // 定义输出类型 response.setContentType("application/msexcel"); ExcelWriter writer = new ExcelWriter(out, ExcelTypeEnum.XLSX); // 写仅有一个 Sheet 的 Excel 文件, 此场景较为通用 Sheet sheet1 = new Sheet(1, 0); // 设置标题 Table table = new Table(1); List&lt;List&lt;String&gt;&gt; titles = new ArrayList&lt;List&lt;String&gt;&gt;(); for (String title : titleList)&#123; titles.add(Arrays.asList(title)); &#125; table.setHead(titles); List&lt;List&lt;Object&gt;&gt; dateList = new ArrayList&lt;&gt;(); mapList.stream().forEach(x-&gt;&#123; List&lt;Object&gt; row = new ArrayList&lt;&gt;(); for (Object str : keys)&#123; Object obj = x.get(str); row.add(obj); &#125; dateList.add(row); &#125;); writer.write1(dateList,sheet1,table); // 第一个 sheet 名称 sheet1.setSheetName("第一个sheet"); // 将上下文中的最终 outputStream 写入到指定文件中 writer.finish(); &#125; catch (Exception e) &#123; log.error("导出[" + fileName + "]报表异常!" + e.getMessage(), e); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; log.error("关闭流异常!" + e.getMessage(), e); &#125; &#125; &#125; &#125; /** * 导入excel * @param inputStream * @param excelListener * @param clazz 需继承BaseRowModel基础类 * @param suffixName 文件后缀 * @throws Exception */ private static void readExcel(InputStream inputStream, ExcelListener excelListener,Class clazz,String suffixName) throws Exception&#123; try &#123; ExcelTypeEnum excelTypeEnum; if (ExcelTypeEnum.XLSX.getValue().equalsIgnoreCase(suffixName)) &#123; excelTypeEnum = ExcelTypeEnum.XLSX; &#125; else if (ExcelTypeEnum.XLS.getValue().equalsIgnoreCase(suffixName)) &#123; excelTypeEnum = ExcelTypeEnum.XLS; &#125;else&#123; throw new Exception("文件上传格式错误"); &#125; ExcelReader excelReader = new ExcelReader(inputStream,excelTypeEnum,null, excelListener); excelReader.read(new Sheet(1,1,clazz)); &#125;catch (Exception e)&#123; log.error("导入文件异常",e); throw new Exception("导入文件失败"); &#125;finally &#123; if(inputStream != null)&#123; inputStream.close(); &#125; &#125; &#125; /** * 读取excel * @param inputStream * @param clazz 需继承BaseRowModel基础类 * @param suffixName * @return * @throws Exception */ public static List&lt;Object&gt; readExcel(InputStream inputStream,Class clazz,String suffixName) throws Exception&#123; ExcelListener listener = new ExcelListener(); readExcel(inputStream,listener,clazz,suffixName); return listener.getDataList(); &#125;&#125; 导出excel的使用类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@Controller@RequestMapping("/commandParse")public class CommandParseController extends BaseAction &#123; @Autowired private CommandParseService commandParseService; /** * 分页查询 */ @RequestMapping("/page") public ModelAndView pageChannel(CommandParse commandParse) &#123; boolean excel = request.getParameter("excel")!= null &amp;&amp; Boolean.parseBoolean(params.get("excel") + ""); try &#123; resultBean = commandParseService.pageAll(excel,commandParse,getBaseConditionVo()); //渠道列表 List&lt;Channel&gt; channels = channelService.getChannelList(); mv.addObject("commandParse",commandParse); mv.addObject("channels",channels); if (excel)&#123; ExportBean exportBean = new ExportBean(); exportBean.setPageNow(0); //导出10万条 exportBean.setPageSize(100000); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); List&lt;CommandParse&gt; list = resultBean.getResults(); map.put("list", list); map.put("param", exportBean); return new ModelAndView(new CommandCodeExport(), map); &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage()); return ajaxDoneError(MessageCode.SERVER_ERROR[1]); &#125; return pageResult(resultBean, "user/ad/pageCommandParse"); &#125;&#125;public class CommandCodeExport extends AbstractExcelView &#123; @Override protected void buildExcelDocument(Map&lt;String, Object&gt; paramMap, HSSFWorkbook workbook, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; @SuppressWarnings("unchecked") List&lt;CommandParse&gt; list = (List&lt;CommandParse&gt;) paramMap.get("list"); ExportBean param = (ExportBean) paramMap.get("param"); //导出显示列 String showClo = (String) paramMap.get("showClo"); DecimalFormat df = new DecimalFormat("#.00"); List&lt;Map&lt;String, Object&gt;&gt; mapList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; //bean转map Map&lt;String,Object&gt; map = ExportExcelUtil.&lt;String, Object&gt; BeanJsonMap(list.get(i)); map.put("id",i+1); map.put("updateTime", DateUtil.formatDate(list.get(i).getUpdateTime(),"yyyy-MM-dd")); if(list.get(i).getStatus()==1)&#123; map.put("status","开启"); &#125;else &#123; map.put("status","关闭"); &#125; mapList.add(map); &#125; String fileName = "书籍口令列表"+DateUtil.formatDate(new Date(),DateUtil.YYYYMMDDHHMMSS); List&lt;String&gt; keysList = new ArrayList&lt;String&gt;(); List&lt;String&gt; titlesList = new ArrayList&lt;String&gt;(); exportPageColKeysTitle(showClo,keysList, titlesList); //调用导出excel方法 ExportExcel.contextLoads(response,fileName,keysList,titlesList,mapList); &#125; private boolean exportPageColKeysTitle(String showClo,List&lt;String&gt; keysList, List&lt;String&gt; titlesList)&#123; Map&lt;String,String&gt; temp = Constants.commandCodeMap; for (Map.Entry&lt;String, String&gt; stringStringEntry : temp.entrySet()) &#123; keysList.add(stringStringEntry.getKey()); titlesList.add(stringStringEntry.getValue()); &#125; return true; &#125; private &lt;K, V&gt; Map&lt;K, V&gt; BeanJsonMap(Object javaBean) &#123; if(javaBean == null ) return null; String json = gson.toJson(javaBean); return JsonUtil.fromJson(json,Map.class); &#125;&#125; 导入excel的使用类12345678910111213141516 /** * 上传Excel文件 */ @RequestMapping("/uploadFileProgress")public ModelAndView uploadFileProgress(@RequestParam(value = "uploadXls", required = false) MultipartFile pkgFile, Long bookListId)&#123; try &#123; String fileName = pkgFile.getOriginalFilename(); String suffixName = fileName.substring(fileName.lastIndexOf(".")); List&lt;Object&gt; dataList = ExportExcel.readExcel(pkgFile.getInputStream(),AppBookListBook.class,suffixName); appBookListBookService.batchSave(dataList,bookListId); &#125;catch (Exception e)&#123; logger.error(e.getMessage()); return ajaxDoneError(MessageCode.SERVER_ERROR[1]); &#125; return ajaxDoneSuccess("保存成功");&#125;]]></content>
      <categories>
        <category>excel</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加解密、压缩工具]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8A%A0%E8%A7%A3%E5%AF%86%E3%80%81%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class SecurityUtil &#123; private static Log log = LogFactory.getLog(SecurityUtil.class); private static SecretKeySpec getSecretKey(String key) throws Exception &#123; SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); DESKeySpec keySpec = new DESKeySpec(key.getBytes()); keyFactory.generateSecret(keySpec); return new SecretKeySpec(keyFactory.generateSecret(keySpec).getEncoded(), "DES"); &#125; /** * 功能描述: DES加密 */ public static String encryptDES(String key, byte[] b) &#123; if (!StringUtils.isEmpty(key) &amp;&amp; b != null &amp;&amp; b.length &gt; 0) &#123; try &#123; SecretKeySpec secretKey = getSecretKey(key); Cipher cipher = Cipher.getInstance("DES"); cipher.init(Cipher.ENCRYPT_MODE, secretKey); return Base64.encodeToString(cipher.doFinal(b), Base64.NO_WRAP); &#125; catch (Throwable throwable) &#123; log.error("DES加密出错", throwable); &#125; &#125; return ""; &#125; /** * 功能描述: DES解密 */ public static byte[] decryptDES(String key, String data) &#123; if (!StringUtils.isEmpty(key) &amp;&amp; !StringUtils.isEmpty(data)) &#123; try &#123; SecretKeySpec secretKey = getSecretKey(key); Cipher cipher = Cipher.getInstance("DES"); cipher.init(Cipher.DECRYPT_MODE, secretKey); return cipher.doFinal(Base64.decode(data, Base64.NO_WRAP)); &#125; catch (Throwable throwable) &#123; log.error("DES解密出错", throwable); &#125; &#125; return null; &#125; /** * 功能描述: RSA加密 */ public static String encryptRSA(String publicKeyString, String data) &#123; if (!StringUtils.isEmpty(publicKeyString) &amp;&amp; !StringUtils.isEmpty(data)) &#123; try &#123; PublicKey key = decodePublicKey(publicKeyString); //Cipher.getInstance("RSA"); Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); cipher.init(Cipher.ENCRYPT_MODE, key); return Base64.encodeToString(cipher.doFinal(data.getBytes()), Base64.NO_WRAP); &#125; catch (Throwable throwable) &#123; log.error("RSA加密出错", throwable); &#125; &#125; return ""; &#125; /** * 功能描述: RSA解密 */ public static String decryptRSA(String privateKeyString, String data) &#123; if (!StringUtils.isEmpty(privateKeyString) &amp;&amp; !StringUtils.isEmpty(data)) &#123; try &#123; PrivateKey key = decodePrivateKey(privateKeyString); //Cipher.getInstance("RSA"); Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); cipher.init(Cipher.DECRYPT_MODE, key); byte[] bytes = cipher.doFinal(Base64.decode(data, Base64.NO_WRAP)); return new String(bytes); &#125; catch (Throwable throwable) &#123; log.error("RSA解密出错", throwable); &#125; &#125; return ""; &#125; private static String encodeKeyToString(Key key)&#123; return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125; private static PrivateKey decodePrivateKey(String key) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); return keyFactory.generatePrivate(keySpec); &#125; private static PublicKey decodePublicKey(String key) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); return keyFactory.generatePublic(keySpec); &#125; /** * 功能描述: 生成RSA的公钥和私钥 */ private static void generateKeyPair() &#123; try &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA"); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); System.out.println("public:\n" + encodeKeyToString(keyPair.getPublic())); System.out.println("private:\n" + encodeKeyToString(keyPair.getPrivate())); &#125; catch (Throwable throwable) &#123; log.error("RSA生成密钥出错", throwable); &#125; &#125; /** * 功能描述: zip压缩 */ public static byte[] compress(String str) &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); if (!StringUtils.isEmpty(str)) &#123; GZIPOutputStream gzip = null; try &#123; gzip = new GZIPOutputStream(out); gzip.write(str.getBytes("utf-8")); gzip.close(); &#125; catch (IOException var6) &#123; var6.printStackTrace(); &#125; &#125; return out.toByteArray(); &#125; /** * 功能描述: zip解压缩 */ public static String uncompress(byte[] bytes) &#123; if (bytes == null || bytes.length == 0) &#123; return null; &#125; ByteArrayOutputStream out = new ByteArrayOutputStream(); ByteArrayInputStream in = new ByteArrayInputStream(bytes); try &#123; GZIPInputStream ungzip = new GZIPInputStream(in); byte[] buffer = new byte[256]; int n; while ((n = ungzip.read(buffer)) &gt;= 0) &#123; out.write(buffer, 0, n); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; return out.toString("utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; String publickey = "dfsfsfdsfsdgfdgdsfgfgfdgfdshgfhthjthbsbfbdfssdfgsdfrhdsB"; String desKey = "ENKLIFANGMINDT123"; TestParam param = new TestParam(); param.setImei("123456789"); param.setImsi("987654321"); String data = JsonUtil.toJson(param); String paramdesrsakey = encryptRSA(publickey, desKey); String paramencryptData = encryptDES(desKey, SecurityUtil.compress(data)); System.out.println("paramdesrsakey:" + paramdesrsakey); System.out.println("paramencryptData:" + paramencryptData); String res = SecurityUtil.uncompress(decryptDES(desKey, paramencryptData)); System.out.println("res:" + res); &#125;&#125;]]></content>
      <categories>
        <category>加解密和压缩</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口上下行json转换]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%8E%A5%E5%8F%A3%E4%B8%8A%E4%B8%8B%E8%A1%8Cjson%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[容器注入MappingJackson2HttpMessageConverter123456789@Configurationpublic class HttpMessageConverterConfig &#123; @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter () &#123; return new PushMappingJackson2HttpMessageConverter(); &#125;&#125; 声名类继承MappingJackson2HttpMessageConverter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class PushMappingJackson2HttpMessageConverter extends org.springframework.http.converter.json.MappingJackson2HttpMessageConverter &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; if(sra!=null)&#123; HttpServletRequest request = sra.getRequest(); String key = request.getHeader(Constants.SecurityConstans.HEADER_ENCRYPTKEY_REQUEST); key = SecurityUtil.decryptRSA(Constants.SecurityConstans.privateKey, key); request.setAttribute(Constants.SecurityConstans.HEADER_ENCRYPTKEY_KEY, key); InputStream body = inputMessage.getBody(); byte[] bytes = new byte[body.available()]; body.read(bytes); String data = ""; if (bytes.length != 0) &#123; data = SecurityUtil.uncompress(SecurityUtil.decryptDES(key, new String(bytes))); &#125; Object obj = null; if (StringUtils.isEmpty(data)) &#123; logger.info("客户端上传数据为空,不予处理"); return obj; &#125; try &#123; obj = this.objectMapper.readValue(data, this.getJavaType(type, contextClass)); &#125; catch (Exception e) &#123; logger.warn("数据解析异常\nJSON：" + data, e.getMessage() + e); &#125; return obj; &#125;else&#123; return super.read(type,contextClass,inputMessage); &#125; &#125; @Override protected void writeInternal(Object object, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; if(sra!=null)&#123; HttpServletRequest request = sra.getRequest(); String uri = request.getRequestURI(); if(uri!= null &amp;&amp; !uri.startsWith("/admin/"))&#123; String encryptKey = (String) request.getAttribute(Constants.SecurityConstans.HEADER_ENCRYPTKEY_KEY); if(!StringUtils.isBlank(encryptKey)) &#123; outputMessage.getBody().write(SecurityUtil.encryptDES(encryptKey, SecurityUtil.compress(JsonUtil.toJson(object))).getBytes()); &#125; &#125;else&#123; outputMessage.getBody().write(JsonUtil.toJson(object).getBytes()); &#125; &#125;else&#123; outputMessage.getBody().write(JsonUtil.toJson(object).getBytes()); &#125; &#125;&#125; 常量类1234567891011121314151617181920212223public class Constants &#123; public static final class ReturnResult &#123; public static final String RETURN_RESULT_OK = "ok"; public static final String RETURN_RESULT_FAIL = "fail"; public ReturnResult() &#123; &#125; &#125; public static class SecurityConstans &#123; public static final String HEADER_ENCRYPTKEY_REQUEST = "enKey"; public static final String HEADER_ENCRYPTKEY_KEY = "HEADER_ENTRY_KEY"; //获取项目中resources目录下encrypt.properties private static ResourceBundle securityBundle = ResourceBundle.getBundle("encrypt"); public static String privateKey = securityBundle.getString("privateKey"); public static String publicKey = securityBundle.getString("publicKey"); &#125; public static final String CACHE_PREFIX="cache";&#125; controller1234567891011121314151617181920212223242526272829303132333435363738public class BaseController &#123; public &lt;T&gt; BaseValueVO&lt;T&gt; returnSuccess(T t) &#123; BaseValueVO&lt;T&gt; baseValueVO = new BaseValueVO&lt;T&gt;(); baseValueVO.setData(t); baseValueVO.setStatus(Constants.ReturnResult.RETURN_RESULT_OK); return baseValueVO; &#125;&#125;@Controllerpublic class TestController extends BaseController&#123; /** * 功能描述: 有返回值，状态码200 */ @RequestMapping(value = &#123;"/test"&#125;) @ResponseBody @MetricManage public BaseValueVO&lt;TestValue&gt; updateImei(@RequestBody TestParam testParam) throws Exception &#123; TestValue tv=new TestValue(); tv.setName("test"); tv.setAge(123); return super.returnSuccess(tv); &#125; /** * 无返回值，状态码204 */ @RequestMapping(value = &#123;"/noContentTest"&#125;) @ResponseStatus(HttpStatus.NO_CONTENT) public void test(@RequestBody TestParam testParam)&#123; TestValue tv=new TestValue(); tv.setName("test"); tv.setAge(123); &#125;&#125; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public abstract class TestAbstract &#123; String url; Map baseDataParam; public TestAbstract(String url, Map baseDataParam)&#123; this.url = url; this.baseDataParam = baseDataParam; &#125; public void test() &#123; Map dataParam = new HashMap&lt;&gt;(); dataParam.putAll(baseDataParam); this.initDataParam(dataParam); CloseableHttpResponse httppHttpResponse2 = null; CloseableHttpClient httpClient = HttpClients.createDefault(); try &#123; HttpPost httpPost = new HttpPost(url); httpPost.setHeader("Content-Type", "application/json"); String desKey= UUID.randomUUID().toString(); httpPost.setHeader(Constants.SecurityConstans.HEADER_ENCRYPTKEY_REQUEST,SecurityUtil.encryptRSA(Constants.SecurityConstans.publicKey,desKey)); String json = JsonUtil.toJson(dataParam); httpPost.setEntity(new StringEntity(SecurityUtil.encryptDES(desKey,SecurityUtil.compress(json)), ContentType.APPLICATION_JSON)); httppHttpResponse2 = httpClient.execute(httpPost); System.out.println(httppHttpResponse2.getStatusLine()); if(httppHttpResponse2.getStatusLine().getStatusCode()== HttpStatus.SC_OK) &#123; System.out.println(SecurityUtil.uncompress(SecurityUtil.decryptDES(desKey,EntityUtils.toString(httppHttpResponse2.getEntity())))); &#125;else&#123; System.out.println(httppHttpResponse2.getStatusLine().getStatusCode()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; httppHttpResponse2.close(); httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; protected abstract void initDataParam(Map dataParam); public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public Map getBaseDataParam() &#123; return baseDataParam; &#125; public void setBaseDataParam(Map baseDataParam) &#123; this.baseDataParam = baseDataParam; &#125;&#125;public class TestLogStats &#123; //基础测试数据信息 Map baseDataParam = new HashMap&lt;&gt;(); //基础测试数据信息 List baseDataParamList = new ArrayList(); /** * 有返回值的测试类 */ @Test public void onlineOperateTest() throws UnsupportedEncodingException &#123; String url = "http://localhost:8080/test"; baseDataParamList.add("123"); baseDataParamList.add("456"); new TestAbstract(url, baseDataParam) &#123; @Override protected void initDataParam(Map dataParam) &#123; dataParam.put("imei","123455"); dataParam.put("imsi","999999"); dataParam.put("param",baseDataParamList); &#125; &#125;.test(); &#125; /** * 无返回值的测试类 */ @Test public void noContentTest() throws UnsupportedEncodingException &#123; String url = Config.host.concat("/noContentTest"); new TestAbstract(url, baseDataParam) &#123; @Override protected void initDataParam(Map dataParam) &#123; dataParam.put("imei","123455"); dataParam.put("imsi","999999"); &#125; &#125;.test(); &#125;&#125;]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>压缩</tag>
        <tag>josn转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义注解以及AOP]]></title>
    <url>%2F2019%2F09%2F17%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8AAOP%2F</url>
    <content type="text"><![CDATA[自定义注解123456789101112@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataChangeTrigger &#123; String tableName(); /** * 操作类型 * @return */ String operatorType() default ""; int keyIndex() default 0;&#125; 拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Aspect@Componentpublic class DateChangeAop &#123; protected Logger logger = LoggerFactory.getLogger(this.getClass()); @Around("within(com.zzcm..*) &amp;&amp; @annotation(dataChangeTrigger)") public Object around(ProceedingJoinPoint pjp, DataChangeTrigger dataChangeTrigger) throws Throwable &#123; try &#123; Object o = pjp.proceed(); this.trigger(pjp.getSignature().getName(),pjp.getArgs(),o,dataChangeTrigger); return o; &#125; catch (Throwable e) &#123; throw e; &#125; &#125; private void trigger(String methodName,Object [] inputParam,Object returnValue,DataChangeTrigger dataChangeTrigger) throws Exception &#123; Collection&lt;Object&gt; key; String operatorType=this.parseOperatorType(methodName,dataChangeTrigger); if(operatorType.equals(Constatns.OPERATOR_TYPE_ADD))&#123; key=this.parseKey(returnValue); &#125;else&#123; key=this.parseKey(inputParam[dataChangeTrigger.keyIndex()]); &#125; try &#123; logger.info("刷新缓存!-----"+dataChangeTrigger.tableName() + "-----" + key+"-----"+operatorType); if(CollectionUtils.isEmpty(key)) return; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (Object k:key)&#123; list.add(k.toString()); &#125; CacheBean cacheBean = new CacheBean(dataChangeTrigger.tableName(),list,operatorType); &#125;catch(Exception e)&#123; logger.error(e.getMessage(),e); &#125; &#125; private Collection parseKey(Object o) throws IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Collection key=new ArrayList(); if(o instanceof PKInterface)&#123; key.add(((PKInterface) o).getPK()); &#125;else if(o instanceof Collection)&#123; key.addAll((Collection)o); &#125;else&#123; key.add(o); &#125; return key; &#125; private String parseOperatorType(String methodName,DataChangeTrigger dataChangeTrigger) throws Exception &#123; String operatorType=""; if(StringUtils.isNotEmpty(dataChangeTrigger.operatorType()))&#123; operatorType=dataChangeTrigger.operatorType(); &#125;else&#123; if(methodName.startsWith("save"))&#123; operatorType= Constatns.OPERATOR_TYPE_ADD; &#125;else if(methodName.startsWith("update"))&#123; operatorType= Constatns.OPERATOR_TYPE_UPDATE; &#125;else if(methodName.startsWith("del"))&#123; operatorType= Constatns.OPERATOR_TYPE_DELETE; &#125; &#125; if (!operatorType.equals(Constatns.OPERATOR_TYPE_ADD) &amp;&amp; !operatorType.equals(Constatns.OPERATOR_TYPE_UPDATE) &amp;&amp; operatorType.equals(Constatns.OPERATOR_TYPE_DELETE)) &#123; throw new Exception("operator_type error! operator_type is:" + operatorType); &#125; return operatorType; &#125; private boolean isSimpleObject(Object o)&#123; return o instanceof Integer||o.getClass().isArray(); &#125;&#125; 使用1234@DataChangeTrigger(tableName = "video_television",operatorType = "update") public void updateVideoTelevision(VideoTelevision videoTelevision) &#123; //业务代码 &#125;]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>自定义注解</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地缓存]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[BaseHolder1234567891011121314151617181920212223242526272829303132333435public abstract class BaseHolder&lt;T&gt; &#123; private SortedMap&lt;String, T&gt; map_m = new TreeMap&lt;&gt;(); private SortedMap&lt;String, T&gt; map_s = new TreeMap&lt;&gt;(); private boolean ISMASTER = true; public SortedMap&lt;String,T&gt; getData()&#123; if(ISMASTER)&#123; return map_m; &#125;else&#123; return map_s; &#125; &#125; public void setData(SortedMap&lt;String,T&gt; data)&#123; if(ISMASTER)&#123; map_s = data; &#125;else&#123; map_m = data; &#125; ISMASTER = !ISMASTER; &#125; public T get(String key)&#123; SortedMap&lt;String, T&gt; data = getData(); if(null==data) return null; return getData().get(key); &#125; public SortedMap&lt;String, T&gt; get()&#123; SortedMap&lt;String, T&gt; data = getData(); if(null==data) return null; return data; &#125;&#125; BaseJob 任务的基类1234567891011121314151617181920212223242526272829303132333435363738394041424344@Order(value = 1)public abstract class BaseJob implements CommandLineRunner &#123; protected Logger logger = LoggerFactory.getLogger(this.getClass()); public abstract void execute(); @Override public void run(String... strings) &#123; this.execute(); &#125; /** * 设置holder 缓存 * @param t 缓存数据 * @param baseHolder holder * @param acceptEmpty 是否允许空数据刷缓存 * @param &lt;T&gt; */ protected &lt;T extends SortedMap&gt; void setHolderData(T t, BaseHolder baseHolder, boolean acceptEmpty) &#123; if (t == null) &#123; return; &#125; if (!t.isEmpty()) &#123; baseHolder.setData(t); return; &#125; if (acceptEmpty) &#123; baseHolder.setData(t); &#125; &#125; /** * 设置holder 缓存，不允许空数据刷holder * @param t 缓存数据 * @param baseHolder holder * @param &lt;T&gt; */ protected &lt;T extends SortedMap&gt; void setHolderData(T t, BaseHolder baseHolder)&#123; setHolderData(t,baseHolder,false); &#125;&#125; 定时任务12345678910111213141516171819202122232425262728293031@Componentpublic class AdOriginConfigJob extends BaseJob &#123; @Autowired private AdOriginConfigHolder adOriginConfigHolder; @Scheduled(cron = "$&#123;ad.origin.config.job&#125;") @PostConstruct @Override public void execute() &#123; Constants.JobEnum jobEnum = Constants.JobEnum.AD_ORIGIN_CONFIG_JOB; Long begin=System.currentTimeMillis(); logger.info("JOB &#123;&#125; 开始执行...", jobEnum.getDesc()); String response = ebkSynServiceFeign.getAdOriginConfigList(); try &#123; //1 获取数据 SortedMap&lt;String, List&lt;AdOriginConfigBean&gt;&gt; adOriginConfigHolderSortedMap = 查数据库; //2 设置缓存数据 this.setHolderData(adOriginConfigHolderSortedMap, adOriginConfigHolder,true); &#125; catch (MiroServiceException e) &#123; logger.error("JOB &#123;&#125; 执行失败,CODE &#123;&#125; Message &#123;&#125;", new String[]&#123;jobEnum.getDesc(), e.getCode(), e.getMessage()&#125;, e); &#125; catch (Exception e) &#123; logger.error("JOB &#123;&#125; 执行失败!", jobEnum.getDesc()); logger.error(e.getMessage(), e); &#125; Long end=System.currentTimeMillis(); logger.info("JOB &#123;&#125; 执行结束...,花费&#123;&#125;毫秒", jobEnum.getDesc(),end-begin); &#125;&#125; CacheManager1234567891011@Service("cacheManager")@Slf4jpublic class CacheManager &#123; @Autowired private AdOriginConfigHolder adOriginConfigHolder; public List&lt;AdOriginConfigBean&gt; getAdOriginConfigList() &#123; List&lt;AdOriginConfigBean&gt; adOriginConfigBeanList = adOriginConfigHolder.get(Constants.JOB_LIST_DEFAULT_KEY); return adOriginConfigBeanList; &#125;&#125; 定时任务线程池,为了达到并行12345678@Configurationpublic class SchedukeConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) &#123; scheduledTaskRegistrar.setScheduler(Executors.newScheduledThreadPool(10)); &#125;&#125; 启动类1234567@SpringBootApplication@EnableSchedulingpublic class EbkPushApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EbkPushApplication.class, args); &#125;&#125;]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F09%2F16%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[tail-f fileName命令1234用于查看文件内容最后10行数据，ctrl+c退出。 最基本的是cat、more和less。看的是文件全部内容，内容很多的话，不方便。tail -f [ -n Number ] [ File ] 查看最新的，会刷新，可以用ctrl+c 来终止例如：tail -f -n 10 fileName 查看最后10行最新消息。（默认是10行） chmod授权方式。123chown -R更改文件夹的用户tmp 目录为所有用户可读可写权限：chmod -R 777 /tmp 修改 tmp 目录所属用户为 root，用户组为 root ： chown -R root:root /tmp 详细查看某个java项目有没有起、以及项目的进程PID12(1)ps -ef |grep 项目名(2)jps -l --&gt;查看所有java的进程 查看linux的各个磁盘的使用率和所占空间1df -h 查看当前目录及子目录的大小1du -h 查看当前目录的一级目录的大小123 du -ah --max-depth=1``` ## 查看所有文件的详情 ll -h 123## cd ~查看某个目录 ``` cd .. 查看上一层目录 cd -回到上次的目录 查找文件123find /home/ad -name iad* 查看/home/ad目录下前缀为iad的所有文件find /home/ad -inname iad* 查看/home/ad目录下前缀为iad的所有文件（忽略大小写）find /home/ad -size +20M 查看/home/ad目录下大于20M的所有文件 压缩和解压12345678910111213141516(1)zip 文件①zip 文件名.zip 源文件 ---》压缩文件②zip 目录名.zip 源目录 ----》压缩目录③unzip 压缩文件名.zip ---》解压文件④unzip -r 压缩目录名.zip ---》解压目录(2)tar 文件①tar -cvf 压缩文件名.tar 源文件 ---》压缩文件②tar -xvf 压缩文件名.tar ---》解压文件(3)tag.gz 文件①tar -zcvf 压缩文件名.tar.gz 源文件 ---》压缩文件②tar -zxvf 压缩文件名.tar.gz ---》解压文件(4)gz①gzip 文件名.gz 源文件 ---》压缩文件②gzip -r 目录名.gz 源目录 ----》压缩目录③guzip 文件名.gz ----》解压文件④guzip -r 目录名.gz ---》解压目录 查看输入命令的历史记录1history 输出重定向12(1)shell命令 &gt;&gt; 文件名.log 2&gt;&amp;1 同时追加正确命令和错误命令到 指定文件(2)shell命令 &gt;&gt;文件.log 1 2&gt;&gt;文件.log 2 把正确的命令输出到文件1错误的文件2 查看路由表1route -n 将本机文件复制到远程服务器上12scp 文件的绝对路径 root@远程ip:远程具体目录Lg: scp /home/ad/log.txt root@192.168.1.110:/home/log 常用快捷键1ctrl+c 终止当前命令 ctrl+l 清屏 相当于clear]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea快捷键]]></title>
    <url>%2F2019%2F09%2F16%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用快捷键 快捷键 提示 alt+insert 生成代码(如get,set方法,构造函数等) alt+enter 导入包 alt+F7 查看某个方法在哪里有用到,或者按ctrl+鼠标点击 ctrl+e 最近更改的代码 ctrl+r 替换文本 ctrl+f 查找文本 ctrl+空格 代码提示 ctrl+p 方法参数提示 ctrl+shit+space 自动提示 ctrl+shit+enter 自动补全 ctrl+x 删除行 ctrl+d 复制行 ctrl＋F12 可以显示当前文件的结构 ctrl+alt+ left/right 返回至上次浏览的位置 ctrl＋alt＋t 可以把代码包在一块内，例如try/catch if ctrl+alt+l 格式化代码 ctrl+alt+o 去掉没有用的import包 ctrl+alt+t 快速生成if else try catch ctrl+h 查询类的父类和子类的层级关系 ctrl+alt+b 查看子类方法实现 ctrl+/ 或 ctrl+chift+/ 注释（// 或者/…/ ） shift+shift 搜索任何東西 shift+F6 重构 – 重命名 ctrl+n 查找哪个类 ctrl+shift+n 查找哪个文件 ctrl+z 撤回 ctrl+shift+z 恢复撤回 图片]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown使用手册]]></title>
    <url>%2F2019%2F08%2F27%2FMarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 换行1&lt;/br&gt; 分割线1*** 文字样式1234567891011*斜体***加粗**==高亮==~~划线~~&lt;font color=#2196F3 size=2 face=&quot;宋体&quot;&gt;宋体大小为2蓝色的字&lt;/font&gt;&lt;center&gt;居中&lt;/center&gt; 斜体加粗==高亮==划线宋体大小为2蓝色的字 居中 列表123- 列表1 - 列表1.1 - 列表1.2 列表1 列表1.1 列表1.2 链接以及图片123[少数派](https://sspai.com/)![logo](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2634294714,2265844648&amp;fm=58&amp;s=4EE6885691B0CD92947DB9F002005035&amp;bpow=121&amp;bpoh=75) 少数派 logo 表格1234大标题1|大标题2|大标题3--|--|--内容1|内容2|内容3内容1|内容2|内容3 大标题1 大标题2 大标题3 内容1 内容2 内容3 内容1 内容2 内容3 插入图片 大小设置12方案一：默认大小 ![](/images/Desert.jpg) 方案二：设置大小 &lt;img width=400 src=&quot;/images/Desert.jpg&quot; &gt;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonUtils]]></title>
    <url>%2F2019%2F08%2F27%2FjsonUtils%2F</url>
    <content type="text"><![CDATA[jsonUtil工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.zzcm.shortvideospider.util;import com.fasterxml.jackson.core.JsonParseException;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.text.SimpleDateFormat;import java.util.Map;public class JsonUtil &#123; private static final Logger logger = LoggerFactory.getLogger(JsonUtil.class); private static final ObjectMapper mapper = new ObjectMapper(); public static ObjectMapper getMapper() &#123; return mapper; &#125; public static String toJson(Object object) &#123; String json = null; try &#123; json = mapper.writeValueAsString(object); &#125; catch (JsonProcessingException var3) &#123; logger.warn(var3.getMessage(), var3); &#125; return json; &#125; /** * 功能描述: fromJson(Stinrg,List.class,Map.class) * @Author: fjk * @Date: 2019/8/27 14:00 */ public static &lt;T&gt; T fromJson(String json, Class&lt;?&gt; collectionClass, Class... elementClasses) &#123; Object t = null; try &#123; t = mapper.readValue(json, mapper.getTypeFactory().constructParametricType(collectionClass, elementClasses)); &#125; catch (Exception var5) &#123; logger.warn(var5.getMessage(), var5); &#125; return (T) t; &#125; public static &lt;T&gt; T object(String json, Class&lt;T&gt; clazz) &#123; if(StringUtils.isEmpty(json)) &#123; return null; &#125; try &#123; return mapper.readValue(json, clazz); &#125; catch (JsonParseException var3) &#123; logger.error("JsonParseException", var3); &#125; catch (RuntimeException var4) &#123; logger.error("Runtime exception " + StringUtils.abbreviate(json, 80), var4); &#125; catch (Exception var5) &#123; logger.error("Exception " + StringUtils.abbreviate(json, 80), var5); &#125; return null; &#125; public static &lt;T&gt; T object(String json, TypeReference typeReference) &#123; Object t = null; try &#123; t = mapper.readValue(json, typeReference); &#125; catch (Exception var4) &#123; logger.warn(var4.getMessage(), var4); &#125; return (T) t; &#125; public static Map&lt;String, ?&gt; getMapFromJson(String json) &#123; Map map = null; try &#123; map = (Map)mapper.readValue(json, Map.class); &#125; catch (Exception var3) &#123; logger.warn(var3.getMessage(), var3); &#125; return map; &#125; static &#123; mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); &#125;&#125; bean转json字符串1String str = JsonUtil.toJson(Bean); json字符串转一层bean1Bean bean = JsonUtil.object(String,Bean.class); json字符串转多层嵌套bean1Bean bean = JsonUtil.object(String,new TypeReference(Bean)&#123;&#125;); json字符串转Map1Map&lt;Sintrg,Objext&gt; map = JsonUtil.getMapFromJson(Bean); json字符串转List&lt;Map&lt;Sintrg,Objext&gt;&gt;1List&lt;Map&lt;Sintrg,Objext&gt;&gt; listMap = fromJson(Stinrg,List.class,Map.class);]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo bulid]]></title>
    <url>%2F2019%2F08%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: baiduMore info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo rule</tag>
      </tags>
  </entry>
</search>
